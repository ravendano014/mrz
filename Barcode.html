<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Barcode Detector — Cámara + Beep + Guía</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/skeleton/2.0.4/skeleton.min.css'>
  <style>
    :root {
      --bg:#0b1220; --fg:#e5e7eb; --card:#0f172a; --accent:#60a5fa; --muted:#94a3b8; --line:#1f2937;
      --ok:#22c55e; --btn:#2563eb; --btn2:#1f2937;
    }
    * { box-sizing:border-box }
    body { margin:0; background:var(--bg); color:var(--fg); font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial,sans-serif }
    header { padding:16px 18px; border-bottom:1px solid var(--line) }
    h1 { margin:0; font-size:18px }
    main { display:grid; gap:16px; padding:16px }
    @media (min-width:960px){ main { grid-template-columns: 1.1fr 1fr } }
    .card { background:var(--card); border:1px solid var(--line); border-radius:16px; overflow:hidden }
    .card h2 { margin:0; padding:10px 14px; border-bottom:1px solid var(--line); color:var(--accent); font-size:14px }
    .card .body { padding:12px }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-top:8px }
    .btn { background:var(--btn); color:#fff; border:none; border-radius:12px; padding:10px 14px; font-weight:600; cursor:pointer }
    .btn.secondary { background:var(--btn2) }
    .btn.success { background:#059669 }
    .hint { color:var(--muted); font-size:12px; margin:8px 0 }
    pre { white-space:pre-wrap; word-break:break-word; max-height:52vh; overflow:auto; background:#0b1220; padding:12px; border-radius:12px; border:1px solid var(--line) }
    #encoding, #imgUrl { background:var(--card); color:var(--fg); border:1px solid var(--line); border-radius:8px; padding:8px }
    #imgUrl { width:25em; max-width:100% }
    #imgUrl.active { color:#fff; background:var(--accent) }
    .viewport { display:inline-block; position:relative; width:100%; max-width:720px; aspect-ratio:4/3; background:#000; border-radius:12px; overflow:hidden; border:1px solid var(--line) }
    video, img, canvas { position:absolute; inset:0; width:100%; height:100%; object-fit:cover }
    #img, #note { display:none }
    /* Marco guía permanente (recuadro verde) */
    .guide { pointer-events:none; position:absolute; inset:0 }
  </style>
</head>
<body>
  <header><h1>Barcode Detector</h1></header>

  <main>
    <section class="card">
      <h2>Entrada</h2>
      <div class="body">
        <div class="row">
          <input id="fileInput" type="file" accept="image/*" style="display:none">
          <input id="imgUrl" type="url" placeholder="Pega la URL de una imagen y presiona fuera" />
          <button id="imgBtn" class="btn">Imagen (archivo)</button>
          <select id="encoding" title="Decodificación">
            <option value="utf-8" selected>UTF-8</option>
            <option value="iso-8859-15">ISO-8859-15</option>
            <option value="windows-1252">Windows-1252</option>
            <option value="macintosh">Macintosh</option>
          </select>
        </div>

        <div class="row">
          <button id="startBtn" class="btn">Iniciar cámara</button>
          <button id="stopBtn" class="btn secondary">Detener cámara</button>
          <label><input id="beepChk" type="checkbox"> Sonido al detectar</label>
          <label><input id="details" type="checkbox"> Mostrar detalles</label>
        </div>

        <p class="hint">Consejo: centra el código dentro del recuadro verde para mejorar la lectura.</p>

        <div class="viewport">
          <video id="video" muted autoplay playsinline></video>
          <img id="img" crossorigin="anonymous" alt="">
          <canvas id="canvas"></canvas>
          <canvas id="guide" class="guide"></canvas>
        </div>

        <p id="note">Si la imagen no aparece, el servidor donde está alojada podría estar bloqueándola por CORS.</p>
        <div class="hint">Formatos compatibles detectados por el navegador: <span id="formats"></span></div>
      </div>
    </section>

    <section class="card">
      <h2>Resultado</h2>
      <div class="body">
        <pre id="result"></pre>
      </div>
    </section>
  </main>

  <script type="module">
    import { BarcodeDetectorPolyfill } from "https://cdn.jsdelivr.net/npm/@undecaf/barcode-detector-polyfill@latest/dist/main.js";

    const el = {};
    document.querySelectorAll('[id]').forEach(e => el[e.id] = e);

    const canvas = el.canvas;
    const ctx = canvas.getContext('2d');
    const guide = el.guide;
    const gctx = guide.getContext('2d');

    let supportedFormats = [];
    let detector = null;
    let requestId = null;
    let stream = null;

    // --- Sonido de beep (WebAudio) ---
    let audioCtx = null;
    let lastBeepAt = 0;
    function beep() {
      // Evita beeps demasiado seguidos
      const now = performance.now();
      if (now - lastBeepAt < 600) return;
      lastBeepAt = now;

      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.value = 880;     // tono característico
      gain.gain.value = 0.08;        // volumen suave
      osc.connect(gain).connect(audioCtx.destination);
      osc.start();
      setTimeout(() => osc.stop(), 150);
    }

    // --- Detector ---
    async function createDetector() {
      supportedFormats = await BarcodeDetectorPolyfill.getSupportedFormats();
      el.formats.textContent = supportedFormats.join(', ');
      detector = new BarcodeDetectorPolyfill({
        formats: supportedFormats,
        zbar: { encoding: el.encoding.value }
      });
    }

    // --- Dibuja guía permanente (recuadro verde centrado con esquinas) ---
    function drawGuide() {
      const W = guide.width = guide.clientWidth;
      const H = guide.height = guide.clientHeight;
      gctx.clearRect(0, 0, W, H);

      // Marco de referencia ~ 70% del ancho, 60% del alto
      const w = Math.round(W * 0.72);
      const h = Math.round(H * 0.62);
      const x = Math.round((W - w) / 2);
      const y = Math.round((H - h) / 2);
      const r = 14;  // radios de esquina
      const L = 22;  // longitud de marcas de esquina

      gctx.lineWidth = 3;
      gctx.strokeStyle = '#00e000';
      gctx.beginPath();
      // Esquinas tipo "L"
      // Esquina sup-izq
      gctx.moveTo(x, y + L); gctx.lineTo(x, y); gctx.lineTo(x + L, y);
      // sup-der
      gctx.moveTo(x + w - L, y); gctx.lineTo(x + w, y); gctx.lineTo(x + w, y + L);
      // inf-izq
      gctx.moveTo(x, y + h - L); gctx.lineTo(x, y + h); gctx.lineTo(x + L, y + h);
      // inf-der
      gctx.moveTo(x + w - L, y + h); gctx.lineTo(x + w, y + h); gctx.lineTo(x + w, y + h - L);
      gctx.stroke();

      // Borde suave punteado
      gctx.setLineDash([8, 8]);
      gctx.lineDashOffset = 0;
      gctx.strokeStyle = 'rgba(0,224,0,0.6)';
      gctx.lineWidth = 2;
      gctx.strokeRect(x, y, w, h);
      gctx.setLineDash([]);
    }

    // --- Detección genérica ---
    async function detect(source) {
      const sW = source.naturalWidth || source.videoWidth || source.width || guide.width;
      const sH = source.naturalHeight || source.videoHeight || source.height || guide.height;

      // Ajusta canvas de dibujo de overlays
      canvas.width = sW;  canvas.height = sH;
      ctx.clearRect(0, 0, sW, sH);

      const symbols = await detector.detect(source);

      // Dibuja polígonos sobre códigos
      for (const symbol of symbols) {
        const pts = symbol.cornerPoints || [];
        if (pts.length) {
          ctx.beginPath();
          const last = pts[pts.length - 1];
          ctx.moveTo(last.x, last.y);
          for (const p of pts) ctx.lineTo(p.x, p.y);
          ctx.lineWidth = 3;
          ctx.strokeStyle = '#00e000';
          ctx.stroke();
        }
      }

      // Limpia detalles sensibles si no se solicitan
      const out = symbols.map(s => {
        const obj = { ...s };
        if (!el.details.checked) {
          delete obj.boundingBox;
          delete obj.cornerPoints;
        }
        return obj;
      });

      el.result.textContent = JSON.stringify(out, null, 2);

      // Beep opcional
      if (el.beepChk.checked && symbols.length) beep();
    }

    // --- Bucle de vídeo ---
    function detectVideoLoop(on) {
      if (on) {
        detect(el.video).then(() => requestId = requestAnimationFrame(() => detectVideoLoop(true)));
      } else {
        if (requestId) cancelAnimationFrame(requestId);
        requestId = null;
      }
    }

    // --- Fuente: IMAGEN (URL o archivo) ---
    function detectImg() {
      // Detén cualquier flujo previo
      stopCamera();

      // Espera pequeño para FF antes de decode()
      setTimeout(() => el.img.decode().then(() => detect(el.img)), 100);
      el.img.style.display = 'block';
      el.video.style.display = 'none';
    }

    // --- Cámara: iniciar / detener ---
    async function startCamera() {
      if (requestId) return; // ya corriendo
      try {
        stream = await navigator.mediaDevices.getUserMedia({ audio: false, video: { facingMode: 'environment' } });
        el.video.srcObject = stream;
        el.video.style.display = 'block';
        el.img.style.display = 'none';
        detectVideoLoop(true);
      } catch (err) {
        el.result.textContent = JSON.stringify(err);
      }
    }

    function stopCamera() {
      detectVideoLoop(false);
      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }
    }

    // --- Listeners y arranque ---
    await createDetector();
    drawGuide();

    // Redibuja guía al redimensionar
    const ro = new ResizeObserver(drawGuide);
    ro.observe(document.querySelector('.viewport'));

    el.encoding.addEventListener('change', createDetector);

    el.imgUrl.addEventListener('change', () => {
      if (!el.imgUrl.value || !el.imgUrl.validity.valid) return;
      el.imgUrl.classList.add('active');
      el.img.src = el.imgUrl.value;
      detectImg();
    });
    el.imgUrl.addEventListener('focus', () => {
      if (el.imgUrl.value && el.imgUrl.validity.valid) {
        el.imgUrl.classList.add('active');
      }
    });

    el.fileInput.addEventListener('change', () => {
      const file = el.fileInput.files?.[0];
      if (!file) return;
      el.imgUrl.classList.remove('active');
      el.img.src = URL.createObjectURL(file);
      el.fileInput.value = '';
      detectImg();
    });

    el.imgBtn.addEventListener('click', () => el.fileInput.click());

    // Controles de cámara explícitos
    el.startBtn.addEventListener('click', startCamera);
    el.stopBtn.addEventListener('click', stopCamera);

    // Habilita contexto de audio al primer gesto del usuario (requisito de navegadores)
    ['click','change'].forEach(evt => {
      document.addEventListener(evt, () => {
        if (!audioCtx && el.beepChk.checked) {
          try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch {}
        }
      }, { once:true, capture:true });
    });
  </script>
</body>
</html>
