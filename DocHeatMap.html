<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Mapa de Calor y JSON desde Imagen (Modo Oscuro)</title>
<!-- Incluir Tesseract.js para OCR -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>
<style>
  :root {
    color-scheme: dark;
    --bg: #0f1115;
    --panel: #151922;
    --panel-2: #1b2030;
    --text: #e6eaf2;
    --muted: #9aa4b2;
    --accent: #7aa2ff;
    --ok: #2ecc71;
    --warn: #f1c40f;
    --err: #e74c3c;
    --border: #263043;
  }
  * { box-sizing: border-box; }
  body {
    margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Segoe UI Emoji";
    background: radial-gradient(1200px 800px at 20% -10%, #1a2030 0%, var(--bg) 50%) fixed, var(--bg);
    color: var(--text);
  }
  header {
    padding: 18px 20px; border-bottom: 1px solid var(--border);
    position: sticky; top: 0; background: rgba(15,17,21,.9); backdrop-filter: blur(6px);
  }
  h1 { margin: 0; font-size: 18px; letter-spacing: .3px; }
  main { padding: 18px; max-width: 1200px; margin: 0 auto; }

  .grid {
    display: grid; gap: 16px;
    grid-template-columns: 1fr;
  }
  @media (min-width: 980px) {
    .grid {
      grid-template-columns: 320px 1fr;
    }
  }

  .card {
    background: linear-gradient(180deg, var(--panel) 0%, var(--panel-2) 100%);
    border: 1px solid var(--border); border-radius: 14px; padding: 14px;
    box-shadow: 0 6px 20px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.02);
  }
  .card h2 { margin: 0 0 10px; font-size: 15px; font-weight: 600; color: #c9d6ff; }
  label { font-size: 13px; color: var(--muted); display: block; margin-bottom: 8px; }
  input[type="file"] {
    width: 100%; padding: 10px; border: 1px dashed var(--border); border-radius: 10px;
    background: #111522; color: var(--muted);
  }
  .row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
  .row > * { flex: 1; }
  button {
    appearance: none; border: 1px solid var(--border); border-radius: 10px; padding: 10px 14px;
    background: #111827; color: #dbe2f7; font-weight: 600; cursor: pointer;
    transition: transform .05s ease, background .2s ease, border-color .2s ease;
  }
  button:hover { background: #0d1422; border-color: #344766; }
  button.primary { background: #16233a; border-color: #2a4270; color: #e7efff; }
  button.primary:hover { background: #192a47; }
  .mini { font-size: 12px; padding: 6px 10px; }
  button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .preview {
    display: grid; gap: 12px;
    grid-template-columns: 1fr;
  }
  @media (min-width: 820px) {
    .preview {
      grid-template-columns: 1fr 1fr;
    }
  }
  .panel {
    background: #0e1422; border: 1px solid var(--border); border-radius: 12px; padding: 10px;
  }
  canvas, img { width: 100%; height: auto; display: block; border-radius: 8px; background: #0b0f1a; }

  textarea {
    width: 100%; min-height: 120px; resize: vertical;
    background: #0b1020; color: #dbe2f7; border: 1px solid var(--border);
    border-radius: 10px; padding: 10px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    font-size: 12px;
  }

  table {
    width: 100%; border-collapse: collapse; border: 1px solid var(--border);
    border-radius: 10px; overflow: hidden; background: #0c111c;
  }
  thead th {
    text-align: left; font-size: 12px; color: #a9b7d1; background: #101727; padding: 8px; border-bottom: 1px solid var(--border);
  }
  tbody td {
    font-size: 12px; color: #e6ebff; padding: 8px; border-top: 1px solid #1c2537;
  }
  .tags { display: inline-flex; gap: 6px; flex-wrap: wrap; }
  .tag { background: #0e172a; border: 1px solid #213050; color: #cfe0ff; padding: 2px 6px; border-radius: 999px; font-size: 11px; }
  .muted { color: var(--muted); }
  .foot { margin-top: 6px; font-size: 11px; color: var(--muted); }
  
  .progress-bar {
    width: 100%; height: 6px; background: #0e1422; border-radius: 3px; overflow: hidden; margin: 8px 0;
  }
  .progress-fill {
    height: 100%; background: var(--accent); border-radius: 3px; transition: width 0.3s ease;
  }
  .ocr-results {
    margin-top: 16px;
  }
  .ocr-item {
    background: #0c111c; border: 1px solid var(--border); border-radius: 8px; padding: 10px; margin-bottom: 8px;
  }
  .ocr-item-header {
    display: flex; justify-content: between; margin-bottom: 6px;
  }
  .ocr-id {
    font-weight: bold; color: var(--accent);
  }
  .ocr-confidence {
    font-size: 11px; color: var(--muted);
  }
  .ocr-text {
    font-size: 13px; line-height: 1.4;
  }
</style>
</head>
<body>
<header>
  <h1>Generador de Mapa de Calor y JSON desde Imagen (DUI / documentos)</h1>
</header>

<main class="grid">
  <!-- Lateral: controles -->
  <section class="card">
    <h2>1) Subir imagen</h2>
    <label>Imagen (JPG/PNG/WebP)</label>
    <input id="file" type="file" accept="image/*">
    <div style="height:8px"></div>

    <h2>2) Parámetros</h2>
    <div class="row">
      <label style="flex:1">
        Tamaño de grilla (hotspots)
        <input id="grid" type="range" min="16" max="64" step="8" value="32" oninput="gridOut.textContent=value+'×'+value">
        <div class="foot">Actual: <span id="gridOut">32×32</span></div>
      </label>
    </div>
    <div class="row">
      <label style="flex:1">
        Top hotspots a listar
        <input id="k" type="range" min="4" max="24" step="2" value="12" oninput="kOut.textContent=value">
        <div class="foot">Actual: <span id="kOut">12</span></div>
      </label>
    </div>

    <h2>3) Generar</h2>
    <div class="row">
      <button class="primary" id="btnGen">Generar mapa de calor + JSON</button>
      <button id="btnJson" class="mini" disabled>Descargar JSON</button>
      <button id="btnPng" class="mini" disabled>Descargar Heatmap PNG</button>
    </div>
    
    <h2>4) Extraer texto (OCR)</h2>
    <div class="row">
      <button id="btnOCR" disabled>Extraer texto de ROIs</button>
    </div>
    <div class="progress-bar" id="progressContainer" style="display: none;">
      <div class="progress-fill" id="progressFill" style="width: 0%"></div>
    </div>
    <div id="ocrStatus" class="foot"></div>
    
    <div class="foot">Todo se procesa localmente en tu navegador. No se suben datos.</div>
  </section>

  <!-- Principal: salidas -->
  <section class="card">
    <h2>Resultados</h2>
    <div class="preview">
      <div class="panel">
        <div class="tags" style="margin-bottom:8px">
          <span class="tag">Original</span>
          <span class="tag muted" id="imgInfo">—</span>
        </div>
        <canvas id="canvasOriginal"></canvas>
      </div>
      <div class="panel">
        <div class="tags" style="margin-bottom:8px">
          <span class="tag">Mapa de calor (mezclado)</span>
          <span class="tag">Base64 más abajo</span>
        </div>
        <canvas id="canvasHeat"></canvas>
      </div>
    </div>

    <div style="height:14px"></div>

    <div class="panel">
      <div class="tags" style="margin-bottom:8px">
        <span class="tag">Base64 – Heatmap PNG</span>
        <span class="tag">Copiar/guardar</span>
      </div>
      <textarea id="b64"></textarea>
    </div>

    <div style="height:14px"></div>

    <div class="panel">
      <div class="tags" style="margin-bottom:8px">
        <span class="tag">Hotspots (JSON → tabla)</span>
      </div>
      <div id="meta" class="foot muted">—</div>
      <div style="height:8px"></div>
      <table id="tbl">
        <thead>
          <tr>
            <th>#</th>
            <th>Score</th>
            <th>Rel (x,y,w,h)</th>
            <th>Px (x,y,w,h)</th>
            <th>Texto extraído</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
    
    <div class="panel ocr-results" id="ocrResults" style="display: none;">
      <div class="tags" style="margin-bottom:8px">
        <span class="tag">Texto extraído (OCR)</span>
      </div>
      <div id="ocrResultsContent"></div>
    </div>
  </section>
</main>

<script>
/* ===========================================================
   Utilidades de imagen / canvas
   =========================================================== */
const fileInput = document.getElementById('file');
const canvasOrig = document.getElementById('canvasOriginal');
const canvasHeat = document.getElementById('canvasHeat');
const ctxO = canvasOrig.getContext('2d');
const ctxH = canvasHeat.getContext('2d');

const gridRange = document.getElementById('grid');
const kRange = document.getElementById('k');
const btnGen = document.getElementById('btnGen');
const btnJson = document.getElementById('btnJson');
const btnPng = document.getElementById('btnPng');
const btnOCR = document.getElementById('btnOCR');
const b64 = document.getElementById('b64');
const tbl = document.querySelector('#tbl tbody');
const meta = document.getElementById('meta');
const imgInfo = document.getElementById('imgInfo');
const progressContainer = document.getElementById('progressContainer');
const progressFill = document.getElementById('progressFill');
const ocrStatus = document.getElementById('ocrStatus');
const ocrResults = document.getElementById('ocrResults');
const ocrResultsContent = document.getElementById('ocrResultsContent');

let currentImage = null;
let currentJSON = null;
let originalImageData = null;

fileInput.addEventListener('change', async (e) => {
  const f = e.target.files?.[0];
  if (!f) return;
  const img = await loadImage(URL.createObjectURL(f));
  currentImage = img;
  drawFit(ctxO, img);
  imgInfo.textContent = `${img.naturalWidth}×${img.naturalHeight}px`;
  // Limpia salidas previas
  ctxH.clearRect(0,0,canvasHeat.width, canvasHeat.height);
  b64.value = '';
  tbl.innerHTML = '';
  meta.textContent = '—';
  btnJson.disabled = true;
  btnPng.disabled = true;
  btnOCR.disabled = true;
  ocrResults.style.display = 'none';
});

btnGen.addEventListener('click', () => {
  if (!currentImage) { alert('Primero selecciona una imagen.'); return; }

  // 1) Ajustar tamaños de canvas
  drawFit(ctxO, currentImage); // asegura dimensiones alineadas
  canvasHeat.width = canvasOrig.width;
  canvasHeat.height = canvasOrig.height;

  // 2) Obtener datos de imagen
  const {width:w, height:h} = canvasOrig;
  originalImageData = ctxO.getImageData(0,0,w,h);

  // 3) Grises
  const gray = toGrayscale(originalImageData);

  // 4) Sobel (bordes)
  const edges = sobel(gray, w, h);

  // 5) Suavizado (blur rápido separable con caja 7x7)
  const blurred = boxBlur(edges, w, h, 3);

  // 6) Normalizar 0..255
  normalizeU8(blurred);

  // 7) Heatmap coloreado
  const heatRGBA = heatmapColorize(blurred, w, h);

  // 8) Mezclar con original (alpha 0.45)
  const blended = blendRGBA(originalImageData.data, heatRGBA, 0.45);

  // 9) Pintar heatmap mezclado
  const out = new ImageData(new Uint8ClampedArray(blended), w, h);
  ctxH.putImageData(out, 0, 0);

  // 10) Base64 PNG
  const dataUrl = canvasHeat.toDataURL('image/png');
  b64.value = dataUrl;

  // 11) Hotspots (grilla)
  const G = parseInt(gridRange.value, 10);
  const K = parseInt(kRange.value, 10);
  const gridScore = gridDensity(blurred, w, h, G);
  const hotspots = topKCells(gridScore, G, G, K);

  // 12) JSON con metadatos y hotspots
  currentJSON = {
    template_name: "auto_hotspots_from_image",
    image_size_px: { width: w, height: h },
    coordinate_system: "relative (0..1)",
    grid_size: { cols: G, rows: G },
    fields: hotspots.map((c, i) => {
      // caja en coordenadas relativas y px
      const x0 = c.col / G, y0 = c.row / G;
      const wRel = 1 / G, hRel = 1 / G;
      return {
        id: i+1,
        type: "hotspot",
        score: Number(c.score.toFixed(3)),
        coordinates: { x: x0, y: y0, width: wRel, height: hRel },
        coordinates_px: {
          x: Math.round(x0 * w),
          y: Math.round(y0 * h),
          width: Math.round(wRel * w),
          height: Math.round(hRel * h)
        },
        extracted_text: "" // Inicialmente vacío, se llenará con OCR
      };
    })
  };

  // 13) Dibujar cajas en el heatmap como overlay
  drawBoxes(ctxH, currentJSON.fields.map(f => f.coordinates_px));

  // 14) Tabla
  fillTable(currentJSON.fields);

  // 15) Meta
  meta.textContent = `Grid: ${G}×${G} • Hotspots: ${currentJSON.fields.length}`;

  // 16) Habilitar descargas
  btnJson.disabled = false;
  btnPng.disabled = false;
  btnOCR.disabled = false;
});

btnJson.addEventListener('click', () => {
  if (!currentJSON) return;
  const blob = new Blob([JSON.stringify(currentJSON, null, 2)], {type:'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'hotspots.json';
  a.click();
  URL.revokeObjectURL(a.href);
});

btnPng.addEventListener('click', () => {
  const a = document.createElement('a');
  a.href = canvasHeat.toDataURL('image/png');
  a.download = 'heatmap.png';
  a.click();
});

btnOCR.addEventListener('click', async () => {
  if (!currentJSON || !currentImage) return;
  
  // Deshabilitar botón durante el procesamiento
  btnOCR.disabled = true;
  progressContainer.style.display = 'block';
  ocrStatus.textContent = 'Iniciando OCR...';
  
  try {
    // Procesar cada ROI con OCR
    for (let i = 0; i < currentJSON.fields.length; i++) {
      const field = currentJSON.fields[i];
      const progress = ((i + 1) / currentJSON.fields.length) * 100;
      progressFill.style.width = `${progress}%`;
      ocrStatus.textContent = `Procesando ROI ${i+1} de ${currentJSON.fields.length}...`;
      
      // Extraer ROI de la imagen original
      const roiCanvas = extractROI(canvasOrig, field.coordinates_px);
      
      // Realizar OCR en la ROI
      const result = await performOCR(roiCanvas);
      
      // Actualizar el campo con el texto extraído
      field.extracted_text = result.text;
      
      // Actualizar la tabla
      updateTableRow(i, result.text, result.confidence);
    }
    
    ocrStatus.textContent = 'OCR completado exitosamente';
    
    // Mostrar resultados en formato legible
    displayOCRResults();
    
  } catch (error) {
    console.error('Error en OCR:', error);
    ocrStatus.textContent = `Error en OCR: ${error.message}`;
  } finally {
    btnOCR.disabled = false;
  }
});

function loadImage(src) {
  return new Promise((res, rej) => {
    const img = new Image();
    img.onload = () => res(img);
    img.onerror = rej;
    img.src = src;
  });
}

function drawFit(ctx, img, maxW=1024, maxH=1024) {
  // Escala de forma no destructiva para mantener calidad en canvas y rendimiento
  const ratio = Math.min(maxW / img.naturalWidth, maxH / img.naturalHeight, 1);
  const w = Math.round(img.naturalWidth * ratio);
  const h = Math.round(img.naturalHeight * ratio);
  ctx.canvas.width = w; ctx.canvas.height = h;
  ctx.drawImage(img, 0, 0, w, h);
}

/* ===========================================================
   Procesamiento de imagen (grayscale, sobel, blur, heatmap)
   =========================================================== */
function toGrayscale(imgData) {
  const {data, width, height} = imgData;
  const out = new Uint8Array(width * height);
  for (let i=0, j=0; i<data.length; i+=4, j++) {
    // luma sRGB aproximada
    out[j] = (data[i]*0.2126 + data[i+1]*0.7152 + data[i+2]*0.0722) | 0;
  }
  return out;
}

function sobel(gray, w, h) {
  const out = new Float32Array(w*h);
  const gxK = [-1,0,1,-2,0,2,-1,0,1];
  const gyK = [-1,-2,-1,0,0,0,1,2,1];
  for (let y=1; y<h-1; y++) {
    for (let x=1; x<w-1; x++) {
      let gx=0, gy=0, k=0;
      for (let j=-1; j<=1; j++) {
        for (let i=-1; i<=1; i++) {
          const v = gray[(y+j)*w + (x+i)];
          gx += v * gxK[k];
          gy += v * gyK[k];
          k++;
        }
      }
      out[y*w + x] = Math.hypot(gx, gy);
    }
  }
  // convertir a U8 lineal 0..255 (sin normalizar aún)
  const u8 = new Uint8Array(w*h);
  // autoescala local simple
  let max=0;
  for (let i=0;i<out.length;i++) if (out[i]>max) max = out[i];
  const inv = max>0 ? 255/max : 0;
  for (let i=0;i<out.length;i++) u8[i] = (out[i]*inv)|0;
  return u8;
}

function boxBlur(src, w, h, radius=2) {
  // blur separable caja: (2*radius+1)
  const tmp = new Uint16Array(w*h);
  const out = new Uint8Array(w*h);
  const k = 2*radius+1;

  // horizontal
  for (let y=0; y<h; y++) {
    let acc=0;
    const row=y*w;
    for (let x=0; x<w; x++) {
      const add = src[row + Math.min(w-1, x+radius)];
      const rem = src[row + Math.max(0, x-radius-1)];
      acc += add - rem;
      tmp[row + x] = acc;
    }
  }
  // vertical + normalización
  for (let x=0; x<w; x++) {
    let acc=0;
    for (let y=0; y<h; y++) {
      const add = tmp[Math.min(h-1, y+radius)*w + x];
      const rem = tmp[Math.max(0, y-radius-1)*w + x];
      acc += add - rem;
      out[y*w + x] = Math.min(255, Math.round(acc / (k*k)));
    }
  }
  return out;
}

function normalizeU8(arr) {
  let lo=255, hi=0;
  for (let i=0;i<arr.length;i++){ if(arr[i]<lo)lo=arr[i]; if(arr[i]>hi)hi=arr[i]; }
  const rng = Math.max(1, hi-lo);
  for (let i=0;i<arr.length;i++){ arr[i] = ((arr[i]-lo)*255/rng) | 0; }
}

function heatmapColorize(u8, w, h) {
  // colormap tipo "jet" compacto
  const out = new Uint8ClampedArray(w*h*4);
  for (let i=0;i<u8.length;i++) {
    const v = u8[i]/255; // 0..1
    const [r,g,b] = jet(v);
    const off = i*4;
    out[off  ] = r;
    out[off+1] = g;
    out[off+2] = b;
    out[off+3] = 255;
  }
  return out;
}

// Jet-like colormap
function jet(x) {
  const r = Math.round(255 * clamp(1.5 - Math.abs(4*x - 3), 0, 1));
  const g = Math.round(255 * clamp(1.5 - Math.abs(4*x - 2), 0, 1));
  const b = Math.round(255 * clamp(1.5 - Math.abs(4*x - 1), 0, 1));
  return [r,g,b];
}
const clamp = (v,a,b)=>Math.min(b,Math.max(a,v));

function blendRGBA(orig, heat, alpha=0.4) {
  const out = new Uint8Array(orig.length);
  for (let i=0;i<orig.length;i+=4) {
    out[i  ] = Math.round(orig[i  ]*(1-alpha) + heat[i  ]*alpha);
    out[i+1] = Math.round(orig[i+1]*(1-alpha) + heat[i+1]*alpha);
    out[i+2] = Math.round(orig[i+2]*(1-alpha) + heat[i+2]*alpha);
    out[i+3] = 255;
  }
  return out;
}

/* ===========================================================
   Hotspots sobre grilla y tabla
   =========================================================== */
function gridDensity(u8, w, h, G) {
  // suma de intensidad por celda GxG
  const gx = G, gy = G;
  const cellW = w / gx, cellH = h / gy;
  const score = new Float32Array(gx*gy);
  for (let row=0; row<gy; row++) {
    for (let col=0; col<gx; col++) {
      const x0 = Math.floor(col*cellW);
      const y0 = Math.floor(row*cellH);
      const x1 = Math.floor((col+1)*cellW);
      const y1 = Math.floor((row+1)*cellH);
      let s=0;
      for (let y=y0; y<y1; y++) {
        let off = y*w + x0;
        for (let x=x0; x<x1; x++) { s += u8[off++]; }
      }
      score[row*gx + col] = s / ((x1-x0)*(y1-y0)); // densidad promedio
    }
  }
  return {score, gx, gy};
}

function topKCells({score, gx, gy}, cols, rows, K) {
  const arr = [];
  for (let row=0; row<rows; row++) {
    for (let col=0; col<cols; col++) {
      arr.push({row, col, score: score[row*cols+col]});
    }
  }
  // ordenar por score desc
  arr.sort((a,b)=>b.score-a.score);

  // supresión no-máxima simple: evita vecinos inmediatos
  const picked = [];
  const taken = new Set();
  for (const c of arr) {
    const key = c.row+','+c.col;
    if (taken.has(key)) continue;
    picked.push(c);
    // marca vecinos de 1 celda a la redonda
    for (let dr=-1; dr<=1; dr++)
      for (let dc=-1; dc<=1; dc++)
        taken.add((c.row+dr)+','+(c.col+dc));
    if (picked.length>=K) break;
  }
  return picked;
}

function drawBoxes(ctx, pxBoxes) {
  ctx.save();
  ctx.lineWidth = 2;
  ctx.strokeStyle = 'rgba(255,255,255,.95)';
  ctx.fillStyle = 'rgba(0,0,0,.25)';
  for (const b of pxBoxes) {
    ctx.strokeRect(b.x+.5, b.y+.5, b.width, b.height);
  }
  ctx.restore();
}

function fillTable(fields) {
  tbl.innerHTML = '';
  fields.forEach((f, i) => {
    const tr = document.createElement('tr');
    const rel = f.coordinates;
    const px = f.coordinates_px;
    tr.innerHTML = `
      <td>${i+1}</td>
      <td>${f.score}</td>
      <td>(${rel.x.toFixed(4)}, ${rel.y.toFixed(4)}, ${rel.width.toFixed(4)}, ${rel.height.toFixed(4)})</td>
      <td>(${px.x}, ${px.y}, ${px.width}, ${px.height})</td>
      <td id="ocr-text-${i}">${f.extracted_text || '—'}</td>
    `;
    tbl.appendChild(tr);
  });
}

function updateTableRow(index, text, confidence) {
  const cell = document.getElementById(`ocr-text-${index}`);
  if (cell) {
    cell.textContent = text || '—';
    if (confidence) {
      cell.title = `Confianza: ${confidence}%`;
    }
  }
}

/* ===========================================================
   Funciones de OCR
   =========================================================== */
function extractROI(sourceCanvas, roi) {
  const { x, y, width, height } = roi;
  
  // Crear un canvas temporal para la ROI
  const roiCanvas = document.createElement('canvas');
  roiCanvas.width = width;
  roiCanvas.height = height;
  const roiCtx = roiCanvas.getContext('2d');
  
  // Dibujar la ROI en el canvas temporal
  roiCtx.drawImage(
    sourceCanvas,
    x, y, width, height,
    0, 0, width, height
  );
  
  return roiCanvas;
}

async function performOCR(canvas) {
  try {
    // Convertir canvas a blob
    const blob = await new Promise(resolve => {
      canvas.toBlob(resolve, 'image/png');
    });
    
    // Realizar OCR con Tesseract
    const { data: { text, confidence } } = await Tesseract.recognize(
      blob,
      'spa+eng', // Español e inglés
      {
        logger: m => {
          // Opcional: mostrar progreso detallado
          if (m.status === 'recognizing text') {
            // Puedes agregar más detalles de progreso aquí si lo deseas
          }
        }
      }
    );
    
    return {
      text: text.trim(),
      confidence: Math.round(confidence)
    };
  } catch (error) {
    console.error('Error en OCR:', error);
    return {
      text: '',
      confidence: 0
    };
  }
}

function displayOCRResults() {
  ocrResults.style.display = 'block';
  ocrResultsContent.innerHTML = '';
  
  currentJSON.fields.forEach((field, index) => {
    if (field.extracted_text && field.extracted_text.trim() !== '') {
      const ocrItem = document.createElement('div');
      ocrItem.className = 'ocr-item';
      
      ocrItem.innerHTML = `
        <div class="ocr-item-header">
          <span class="ocr-id">ROI ${field.id}</span>
          <span class="ocr-confidence">Score: ${field.score}</span>
        </div>
        <div class="ocr-text">${field.extracted_text}</div>
      `;
      
      ocrResultsContent.appendChild(ocrItem);
    }
  });
  
  if (ocrResultsContent.children.length === 0) {
    ocrResultsContent.innerHTML = '<div class="foot muted">No se detectó texto en las ROIs</div>';
  }
}
</script>
</body>
</html>
