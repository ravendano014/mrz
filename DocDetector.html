<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>OCR de Documentos ¬∑ Flujo Definitivo ¬∑ MRZ + PDF417 ¬∑ Dark</title>

  <!-- ====== Librer√≠as por CDN ====== -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/inferencejs@1.1.3"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
  <!-- ZXing (UMD) expone window.ZXing.* (incluye PDF417) -->
  <script src="https://unpkg.com/@zxing/library@latest"></script>

  <style>
    :root{--bg:#0b0f14;--panel:#111820;--muted:#1a2230;--text:#e6eef7;--sub:#9fb3c8;--accent:#5ac8fa;--good:#34d399;--bad:#f87171;--warn:#fbbf24;--border:#1f2a3a}
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;padding:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji"}
    h1{font-size:1.1rem;margin:0 0 .25rem 0}
    .app{display:grid;grid-template-columns:360px 1fr;gap:12px;height:100%;}
    .left{padding:12px;background:var(--panel);border-right:1px solid var(--border);overflow:auto}
    .right{display:grid;grid-template-rows:auto 1fr auto auto;gap:12px;padding:12px}

    .bar{display:flex;flex-wrap:wrap;align-items:center;gap:8px;background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:10px}
    .bar h2{font-size:.95rem;margin:0 10px 0 0;color:var(--sub)}
    .bar .spacer{flex:1 1 auto}

    .stage{position:relative;background:#05080c;border:1px solid var(--border);border-radius:12px;overflow:hidden;min-height:320px}
    .layer{position:absolute;inset:0}
    #video{width:100%;height:100%;object-fit:contain;background:#000}
    #imgPreview{width:100%;height:100%;object-fit:contain;display:none}
    #overlay{touch-action:none}

    .card{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:10px;min-height:0}
    .card h3{margin:0 0 .5rem 0;color:var(--sub);font-size:.95rem}

    .results{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    textarea.raw{width:100%;height:240px;background:#0a121a;color:var(--text);border:1px solid var(--border);border-radius:10px;padding:8px;resize:vertical}
    table{width:100%;border-collapse:collapse}
    th,td{border-bottom:1px solid var(--border);padding:6px 8px;text-align:left;vertical-align:top}
    th{color:var(--sub);font-weight:600}
    .status{font-size:.9rem;color:var(--sub)}
    .badge{display:inline-flex;align-items:center;gap:6px;padding:3px 8px;border-radius:999px;border:1px solid var(--border);background:#0f1720}
    .ok{color:var(--good)}.warn{color:var(--warn)}.err{color:var(--bad)} .info{color:#93c5fd}

    button,input[type=file],input[type=text],input[type=number],select{
      appearance:none;border:none;background:var(--panel);color:var(--text);
      padding:8px 10px;border-radius:10px;border:1px solid var(--border);cursor:pointer
    }
    input[type=text],input[type=number],select{width:100%;cursor:text}
    button:hover{border-color:var(--accent)}
    button.primary{background:linear-gradient(180deg, #132435, #0f1c2a);border-color:#223247}
    button.good{border-color:#17392c;background:#0e2b21}
    button.bad{border-color:#3b1e1e;background:#2a1414}
    button[disabled]{opacity:.55; cursor:not-allowed}

    .fps{position:absolute;bottom:10px;left:10px;background:rgba(0,0,0,.4);padding:4px 8px;border-radius:8px;border:1px solid var(--border);font-size:.8rem}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}

    /* Panel de resultados (m√°x 40% del ancho de pantalla) */
    .results-panel{width:100%;max-width:40vw;}
    .results-scroll{overflow:auto;max-height:260px}
    .muted{color:#6b7a8c}
    .hidden{display:none !important}

    @media (max-width: 1100px){
      .app{grid-template-columns:1fr}
      .left{order:2}
      .right{order:1}
      .results{grid-template-columns:1fr}
      .results-panel{max-width:100%}
    }
  
    .badge.active { border-color: var(--accent); box-shadow: 0 0 0 1px var(--accent) inset; }

    .tab-btn{ padding:6px 10px; border-radius:999px; border:1px solid var(--border); background:#0f1720; cursor:pointer; }
    .tab-btn.primary{ background:var(--muted); }
    .tab-btn.active{ box-shadow:0 0 0 1px var(--accent) inset; }
    .card h3{ position:sticky; top:0; background:var(--panel); z-index:2; padding-top:6px; }
    .btn-icon{ display:inline-flex; align-items:center; gap:6px; }
    .spin{ display:inline-block; width:14px; height:14px; border:2px solid var(--border); border-top-color:var(--accent); border-radius:50%; animation:spin 0.8s linear infinite; vertical-align:-2px; }
    @keyframes spin{ to{ transform:rotate(360deg);} }
    /* Toasts */
    #toastHost{ position:fixed; right:12px; bottom:12px; display:flex; flex-direction:column; gap:8px; z-index:100; }
    .toast{ background:#0f1720; border:1px solid var(--border); border-left:4px solid var(--accent); padding:10px 12px; border-radius:10px; color:var(--text); }
    .toast.err{ border-left-color: var(--bad); }
    .toast.warn{ border-left-color: var(--warn); }
    /* Sidebar resizer */
    #resizeHandle{ position:absolute; top:0; bottom:0; right:-4px; width:8px; cursor:col-resize; }

    /* Mejora: bordes sutiles para barras sticky */
    #appHeader, #topModels{ backdrop-filter: blur(4px); }
</style>
</head>
<body>
  <div class="app">
    <!-- LADO IZQUIERDO -->
    <aside class="left" id="leftPanel" style="position:relative"><div id="resizeHandle" title="Arrastra para redimensionar"></div>
      <h1>OCR de Documentos</h1>

      <div class="card" style="margin-bottom:12px">
        <h3>ROIs (plantilla)</h3>
        <div class="status" id="roiCount" style="margin-bottom:6px">0 ROIs</div>
        <div class="bar" style="padding:8px">
          <button id="btnAddRoi">Agregar ROI</button>
          <button id="btnDeleteRoi" class="bad">Eliminar ROI</button>
          <button id="btnClearRois" class="bad">Limpiar ROIs</button>
        </div>
        <div class="bar" style="padding:8px;margin-top:8px">
          <button id="btnExport">Exportar JSON</button>
          <input type="file" id="fileImport" accept="application/json" />
        </div>
        <!-- Propiedades ROI -->
        <div class="bar" style="padding:8px;margin-top:8px;display:grid;grid-template-columns:1fr 1fr;gap:8px">
          <input id="roiName" type="text" placeholder="Nombre ROI" />
          <select id="roiType">
            <option value="text">text</option>
            <option value="image">image</option>
            <option value="mrz">mrz</option>
            <option value="pdf417">pdf417</option>
            <option value="barcode">barcode</option>
          </select>
          <input id="roiX" type="number" step="0.001" min="0" max="1" placeholder="x (0..1)" />
          <input id="roiY" type="number" step="0.001" min="0" max="1" placeholder="y (0..1)" />
          <input id="roiW" type="number" step="0.001" min="0.02" max="1" placeholder="w (0..1)" />
          <input id="roiH" type="number" step="0.001" min="0.02" max="1" placeholder="h (0..1)" />
        </div>
        <div class="status" style="margin-top:6px">
          Tip: Click para seleccionar ¬∑ Arrastra para mover ¬∑ Arrastra bordes/esquinas para redimensionar ¬∑ Supr/Backspace borra.
        </div>
      </div>

      <div class="card" style="margin-bottom:12px">
        <h3>Extracci√≥n por ROI</h3>
        <div class="bar" style="padding:8px">
          <button id="btnExtractSelected" class="good">Extraer ROI Seleccionado</button>
          <button id="btnExtractAll">Extraer todos los ROIs</button>
        </div>
        <div class="status" style="margin-top:6px">
          Tipos: <span class="mono">text, image, mrz, pdf417, barcode</span>
        </div>
      </div>

      <div class="card">
        <h3>Modelos y estado</h3>
        <div class="status" style="display:grid;gap:6px">
          <div>Engine: <span id="sEngine" class="badge info">inicializando‚Ä¶</span></div>
          <div>
            Modelo Doc (react-project-wdxr6): <span id="sModelDoc" class="badge info">pendiente</span>
            <div style="margin-top:6px; display:flex; gap:6px; flex-wrap:wrap">
              <button id="btnLoadDoc">Cargar Doc</button>
              <button id="btnUnloadDoc" class="bad">Descargar Doc</button>
            </div>
          </div>
          <div>
            Modelo MRZ: <span id="sModelMRZ" class="badge">‚Äî</span>
            <div style="margin-top:6px; display:flex; gap:6px; flex-wrap:wrap">
              <button id="btnLoadMRZ">Cargar MRZ</button>
              <button id="btnUnloadMRZ" class="bad">Descargar MRZ</button>
            </div>
          </div>
          <div>
            Modelo PDF417: <span id="sModelPDF" class="badge">‚Äî</span>
            <div style="margin-top:6px; display:flex; gap:6px; flex-wrap:wrap">
              <button id="btnLoadPDF">Cargar PDF417</button>
              <button id="btnUnloadPDF" class="bad">Descargar PDF417</button>
            </div>
          </div>
        </div>
      </div>
    </aside>

    <!-- LADO DERECHO -->
    <main class="right">
  <header id="appHeader" class="bar" style="position:sticky;top:0;z-index:50;margin-bottom:8px">
    <h1 style="font-size:1rem;margin:0">OCR de Documentos ¬∑ MRZ + PDF417</h1>
    <div class="spacer"></div>
    <button id="btnHelp" title="Ayuda (atajos de teclado)">‚ùì Ayuda</button>
    <label class="status" title="Guardar preferencias de la sesi√≥n">
      <input type="checkbox" id="chkPersist" /> Guardar preferencias
    </label>
  </header>

      <!-- C√°mara -->
      
      <!-- Stepper (Asistente) -->
      
      <!-- Estado modelos (Top) -->
      <div id="topModels" class="bar" style="position:sticky;top:52px;z-index:49;margin-bottom:8px">
        <h2>Estado</h2>
        <div class="status" style="display:flex;flex-wrap:wrap;gap:12px;align-items:center">
          <div>Engine: <span id="sEngineHolder" class="badge">‚Äî</span></div>
          <div>Modelo Doc: <span id="sModelDocHolder" class="badge">‚Äî</span></div>
          <div>MRZ: <span id="sModelMRZHolder" class="badge">‚Äî</span></div>
          <div>PDF417: <span id="sModelPDFHolder" class="badge">‚Äî</span></div>
          <div>FPS: <span id="fpsTop" class="badge mono">‚Äî</span></div>
        </div>
      </div>
<div id="stepper" class="bar" style="margin-bottom:8px">
        <h2>Asistente</h2>
        <div id="steps" class="status">
          <span id="st1" class="badge info">1. Identificar documento</span>
          <span id="st2" class="badge">2. Versi√≥n definitiva</span>
          <span id="st3" class="badge">3. ROIs</span>
          <span id="st4" class="badge">4. Extraer resultados</span>
        </div>
      </div>
<div class="bar" id="cameraBar">
        <h2>C√°mara</h2>
        <button id="btnStart" class="primary">Iniciar</button>
        <button id="btnStop">Detener</button>
        <button id="btnShot" class="good">Capturar Imagen</button>
        <button id="btnShotDoc" class="good">Capturar solo Documento</button>

        <div class="spacer"></div>

        <label class="status" style="display:flex;align-items:center;gap:8px">
          <input type="checkbox" id="chkAutoDoc" /> Auto-detectar Documento
        </label>

        <span id="fps" class="badge mono">FPS: <span id="fpsVal">‚Äî</span></span>
      </div>

      <!-- Stage -->
      <section id="stage" class="stage">
        <video id="video" class="layer" autoplay muted playsinline></video>
        <img id="imgPreview" class="layer" alt="Previsualizaci√≥n" />
        <canvas id="overlay" class="layer"></canvas>
        <div class="fps mono" id="fpsOverlay">‚Äî fps</div>
      </section>

      <!-- Imagen -->
      <div class="bar" id="imageBar">
        <h2>Imagen</h2>
        <input type="file" id="file" accept="image/*" />
        <button id="btnParseFull">Extraer y Parsear (Imagen Completa)</button>
        <button id="btnShotDocImage" class="good" title="Detecta y recorta el documento en la imagen cargada usando el modelo de Documento">Capturar solo Documento (Imagen cargada)</button>

        <!-- Bot√≥n de transici√≥n a versi√≥n definitiva -->
        <button id="btnSetFinal" class="primary" title="Descarga modelo Doc y carga MRZ/PDF417 para pasar a la etapa final">Establecer versi√≥n definitiva</button>

        <div class="spacer"></div>
        <!-- Deshabilitados inicialmente -->
        <button id="btnDetectMRZ" class="primary" disabled>Detectar MRZ en Imagen</button>
        <button id="btnDetectPDF" class="primary" disabled>Detectar PDF417 en Imagen</button>
      </div>

      <!-- Resultados -->
      <section class="results">
        <div class="card">
          <h3>Texto crudo OCR</h3>
          <textarea id="raw" class="raw" placeholder="Aqu√≠ aparecer√° el texto crudo‚Ä¶"></textarea>
          <div style="margin-top:8px">
            <button id="btnParseRaw" title="Parsear el contenido actual del √°rea de texto sin volver a ejecutar OCR">Parsear Texto Crudo</button>
          </div>
        </div>

        <!-- Panel de resultados (m√°x 40% ancho pantalla) -->
        <div class="card results-panel">
          
      <!-- Tabs de Resultados -->
      <div class="bar" id="resultsTabs" style="gap:4px">
        <button class="tab-btn primary" data-tab="pdf417">PDF417</button>
        <button class="tab-btn" data-tab="mrz">MRZ</button>
        <button class="tab-btn" data-tab="rois">ROIs</button>
        <button class="tab-btn" data-tab="raw">Texto crudo</button>
        <div class="spacer"></div>
        <button id="btnCopyVisible" title="Copiar tabla visible">üìã Copiar</button>
        <button id="btnClearVisible" title="Limpiar panel visible">üßπ Limpiar</button>
      </div>
<h3>Datos parseados</h3>
          <div id="status" class="status">Esperando extracci√≥n‚Ä¶</div>

          <!-- PDF417 (arriba) -->
          <div id="pdf417Summary" class="status hidden" style="margin-top:8px"></div>
          <div id="pdf417Error" class="status err hidden" style="margin:6px 0 0 0"></div>
          <div id="pdf417Table" class="results-scroll" style="margin-top:6px"></div>

          <!-- MRZ (debajo de PDF417) -->
          <div id="mrzSummary" class="status hidden" style="margin-top:14px"></div>
          <div id="mrzTable" class="results-scroll" style="margin-top:6px"></div>

          <!-- Tabla de Resultados (ROIs) -->
          <div style="margin-top:14px">
            <div class="status" style="display:flex;align-items:center;gap:8px">
              <strong>Tabla de Resultados (ROIs)</strong>
              <span class="spacer"></span>
              <button id="btnRoiClear" class="bad">Limpiar tabla</button>
              <button id="btnRoiCSV">Exportar CSV</button>
              <button id="btnRoiJSON">Exportar JSON</button>
            </div>
            <div id="roiResults" class="results-scroll" style="margin-top:6px"></div>
          </div>
        </div>
      </section>
    
  <!-- Toasts -->
  <div id="toastHost" aria-live="polite"></div>

  <!-- Ayuda Modal -->
  <dialog id="dlgHelp" style="max-width:720px">
    <h3>Ayuda y atajos de teclado</h3>
    <div class="status" style="margin:8px 0">Usa estos atajos para agilizar el flujo:</div>
    <ul>
      <li><b>S</b> Iniciar c√°mara ¬∑ <b>X</b> Detener ¬∑ <b>C</b> Capturar imagen ¬∑ <b>D</b> Capturar documento</li>
      <li><b>M</b> Detectar MRZ ¬∑ <b>P</b> Detectar PDF417</li>
      <li><b>R</b> Nuevo ROI (arrastrar) ¬∑ <b>Del</b> borrar ROI seleccionado</li>
      <li><b>?</b> Abrir/cerrar esta ayuda</li>
    </ul>
    <div style="display:flex;gap:8px;justify-content:flex-end">
      <button id="btnHelpClose">Cerrar</button>
    </div>
  </dialog>

</main>
  </div>

  <!-- =============== L√ìGICA =============== -->
  <script>
    // ====== Estado global
    const state = {
      stream: null,
      running: false,
      usingImage: false,
      lastDocDetections: [],
      selectedRoiId: null,
      rois: [], // {id,name,type,x,y,w,h} coords relativos [0..1]
      engine: null,
      // Workers
      docWorkerId: null, // react-project-wdxr6 (inicial)
      mrzWorkerId: null, // mrz-ye7hu-5jxuj (etapa final)
      pdfWorkerId: null, // pdf417-kl4vz-hl0le (etapa final)
      activeBitmap: null,
      activeNatural: {w:0,h:0},
      // Fase
      phase: 'draft' // 'draft' (solo Doc) -> 'final' (MRZ+PDF)
    };

    // ====== DOM refs
    const $video = document.getElementById('video');
    const $imgPreview = document.getElementById('imgPreview');
    const $overlay = document.getElementById('overlay');
    const ctx = $overlay.getContext('2d');
    const $fpsOverlay = document.getElementById('fpsOverlay');
    const $fpsVal = document.getElementById('fpsVal');

    const $sEngine = document.getElementById('sEngine');
    const $sModelDoc = document.getElementById('sModelDoc');
    const $sModelMRZ = document.getElementById('sModelMRZ');
    const $sModelPDF = document.getElementById('sModelPDF');

    const $raw = document.getElementById('raw');
    const $status = document.getElementById('status');

    const $btnDetectMRZ = document.getElementById('btnDetectMRZ');
    const $btnDetectPDF = document.getElementById('btnDetectPDF');
    const $btnSetFinal  = document.getElementById('btnSetFinal');

    const $roiCount = document.getElementById('roiCount');
    const $roiName = document.getElementById('roiName');
    const $roiType = document.getElementById('roiType');
    const $roiX = document.getElementById('roiX');
    const $roiY = document.getElementById('roiY');
    const $roiW = document.getElementById('roiW');
    const $roiH = document.getElementById('roiH');

    const pdf417Summary = document.getElementById('pdf417Summary');
    const pdf417Error   = document.getElementById('pdf417Error');
    const pdf417Table   = document.getElementById('pdf417Table');
    const mrzSummary    = document.getElementById('mrzSummary');
    const mrzTable      = document.getElementById('mrzTable');
    const roiResults    = document.getElementById('roiResults');

    // ====== Helpers UI
    // ====== Stepper helpers ======
    function mark(el, text, cls){ if(!el) return; el.className='badge '+(cls||''); el.textContent=text; }
    function updateSteps(stage){
      // stage: 1=borrador listo, 2=final cargada, 3=rois definidos, 4=extrayendo/resultados
      const s1 = document.getElementById('st1');
      const s2 = document.getElementById('st2');
      const s3 = document.getElementById('st3');
      const s4 = document.getElementById('st4');
      mark(s1, '1. Identificar documento', stage>=1?'ok active':'info');
      mark(s2, '2. Versi√≥n definitiva',    stage>=2?'ok active':'');
      mark(s3, '3. ROIs',                   stage>=3?'ok active':'');
      mark(s4, '4. Extraer resultados',     stage>=4?'ok active':'');
    }

    function setBadge(el, text, klass=''){ el.className='badge '+klass; el.textContent=text; }
    function setStatus(msg,isErr){
      $status.innerHTML = `<span class="badge ${isErr?'err':'ok'}">${msg}</span>`;
      try{
        const m = String(msg).toLowerCase();
        if(!isErr && /(ocr completado|decodificado|parseado|transici√≥n a versi√≥n definitiva completada|exportada)/.test(m)){
          if(typeof updateSteps==='function') updateSteps(4);
        }
      }catch(e){}
    }

    // ====== InferenceJS: init engine y carga inicial (solo Doc)

    // ====== NUEVO: Gesti√≥n manual de carga/descarga de modelos ======
    function loadedModelsCount(){
      return [state.docWorkerId, state.mrzWorkerId, state.pdfWorkerId].filter(Boolean).length;
    }
    function canLoadAnother(){
      const c = loadedModelsCount();
      if(c >= 2){
        setStatus('L√≠mite: solo 2 modelos activos a la vez. Descarga alguno para continuar.', true);
        return false;
      }
      return true;
    }
    async function loadDoc(){
      if(state.docWorkerId){ setStatus('Modelo Doc ya cargado.'); return; }
      if(!canLoadAnother()) return;
      try{
        setBadge($sModelDoc,'cargando‚Ä¶','info');
        state.docWorkerId = await state.engine.startWorker('react-project-wdxr6','1','rf_hHUmNcZwoGhdPO3kyAlI6YY4R4m2');
        setBadge($sModelDoc,'OK','ok');
      }catch(e){ console.error(e); setBadge($sModelDoc,'error','err'); }
    }
    async function unloadDoc(){
      if(!state.docWorkerId){ setStatus('Modelo Doc no est√° cargado.'); return; }
      await stopWorkerSafe(state.docWorkerId); state.docWorkerId=null;
      setBadge($sModelDoc,'descargado','warn');
    }
    async function loadMRZ(){
      if(state.mrzWorkerId){ setStatus('Modelo MRZ ya cargado.'); return; }
      if(!canLoadAnother()) return;
      try{
        setBadge($sModelMRZ,'cargando‚Ä¶','info');
        state.mrzWorkerId = await state.engine.startWorker('mrz-ye7hu-5jxuj','1','rf_hHUmNcZwoGhdPO3kyAlI6YY4R4m2');
        setBadge($sModelMRZ,'OK','ok');
        setDetectButtonsEnabled(!!(state.mrzWorkerId && state.pdfWorkerId));
      }catch(e){ console.error(e); setBadge($sModelMRZ,'error','err'); }
    }
    async function unloadMRZ(){
      if(!state.mrzWorkerId){ setStatus('Modelo MRZ no est√° cargado.'); return; }
      await stopWorkerSafe(state.mrzWorkerId); state.mrzWorkerId=null;
      setBadge($sModelMRZ,'descargado','warn'); setDetectButtonsEnabled(false);
    }
    async function loadPDF(){
      if(state.pdfWorkerId){ setStatus('Modelo PDF417 ya cargado.'); return; }
      if(!canLoadAnother()) return;
      try{
        setBadge($sModelPDF,'cargando‚Ä¶','info');
        state.pdfWorkerId = await state.engine.startWorker('pdf417-kl4vz-hl0le','1','rf_hHUmNcZwoGhdPO3kyAlI6YY4R4m2');
        setBadge($sModelPDF,'OK','ok');
        setDetectButtonsEnabled(!!(state.mrzWorkerId && state.pdfWorkerId));
      }catch(e){ console.error(e); setBadge($sModelPDF,'error','err'); }
    }
    async function unloadPDF(){
      if(!state.pdfWorkerId){ setStatus('Modelo PDF417 no est√° cargado.'); return; }
      await stopWorkerSafe(state.pdfWorkerId); state.pdfWorkerId=null;
      setBadge($sModelPDF,'descargado','warn'); setDetectButtonsEnabled(false);
    }

    async function initEngine(){
      try{
        setBadge($sEngine,'inicializando‚Ä¶','info');
        state.engine = new inferencejs.InferenceEngine();
        setBadge($sEngine,'listo','ok');
        await loadDocModelOnly();
      }catch(err){
        console.error(err);
        setBadge($sEngine,'error','err');
      }
    }

    async function loadDocModelOnly(){
      try{
        setBadge($sModelDoc,'cargando‚Ä¶','info');
        state.docWorkerId = await state.engine.startWorker(
          'react-project-wdxr6','1','rf_hHUmNcZwoGhdPO3kyAlI6YY4R4m2'
        );
        setBadge($sModelDoc,'OK','ok');
        // Asegurar que MRZ/PDF est√©n ‚Äú‚Äî‚Äù
        setBadge($sModelMRZ,'‚Äî'); setBadge($sModelPDF,'‚Äî');
        // Deshabilitar detecciones MRZ/PDF
        setDetectButtonsEnabled(false);
        try{ if(typeof updateSteps==='function') updateSteps(1); }catch(e){}
      }catch(e){
        console.error('Error cargando Doc:', e);
        setBadge($sModelDoc,'error','err');
      }
    }

    async function stopWorkerSafe(workerId){
      if(!workerId || !state.engine) return;
      try{
        if (typeof state.engine.stopWorker === 'function'){
          await state.engine.stopWorker(workerId);
        } else if (typeof state.engine.terminateWorker === 'function'){
          await state.engine.terminateWorker(workerId);
        } // si no existe, seguimos; algunos engines no exponen descarga expl√≠cita
      }catch(e){ console.warn('stopWorkerSafe:', e); }
    }

    async function switchToFinalPhase(){
  /*__cleared_rois_on_final__*/
  try{ clearAllRois && clearAllRois(); }catch(e){}

      if(state.phase!=='draft') return;
      // Confirmaci√≥n
      const ok = confirm('¬øEstablecer versi√≥n definitiva? Se descargar√° el modelo de Documento y se cargar√°n MRZ y PDF417.');
      if(!ok) return;

      // 1) Descargar modelo Doc
      try{
        setBadge($sModelDoc,'descargando‚Ä¶','info');
        await stopWorkerSafe(state.docWorkerId);
        state.docWorkerId = null;
        setBadge($sModelDoc,'descargado','warn');
      }catch(e){
        console.warn('Fallo descargando Doc:', e);
        setBadge($sModelDoc,'descargado*','warn');
      }

      // 2) Cargar MRZ y PDF417
      try{
        setBadge($sModelMRZ,'cargando‚Ä¶','info');
        state.mrzWorkerId = await state.engine.startWorker(
          'mrz-ye7hu-5jxuj','1','rf_hHUmNcZwoGhdPO3kyAlI6YY4R4m2'
        );
        setBadge($sModelMRZ,'OK','ok');
      }catch(e){
        console.error('Error cargando MRZ:', e);
        setBadge($sModelMRZ,'error','err');
      }

      try{
        setBadge($sModelPDF,'cargando‚Ä¶','info');
        state.pdfWorkerId = await state.engine.startWorker(
          'pdf417-kl4vz-hl0le','1','rf_hHUmNcZwoGhdPO3kyAlI6YY4R4m2'
        );
        setBadge($sModelPDF,'OK','ok');
      }catch(e){
        console.error('Error cargando PDF417:', e);
        setBadge($sModelPDF,'error','err');
      }

      // 3) Habilitar UI detecci√≥n MRZ/PDF si ambos listos
      const ready = !!(state.mrzWorkerId && state.pdfWorkerId);
      setDetectButtonsEnabled(ready);
      if(ready){ state.phase='final'; setStatus('Transici√≥n a versi√≥n definitiva completada.'); try{ if(typeof updateSteps==='function') updateSteps(2); }catch(e){} }
      else { setStatus('Transici√≥n incompleta: ver errores de carga.', true); }
    }

    function setDetectButtonsEnabled(on){
      $btnDetectMRZ.disabled = !on;
      $btnDetectPDF.disabled = !on;
    }

    // ====== Overlay y resize
    function resizeOverlay(){
      const host = state.usingImage ? $imgPreview : $video;
      const w = host.clientWidth || host.getBoundingClientRect().width;
      const h = host.clientHeight || host.getBoundingClientRect().height;
      $overlay.width  = Math.round(w * devicePixelRatio);
      $overlay.height = Math.round(h * devicePixelRatio);
      $overlay.style.width  = w + 'px';
      $overlay.style.height = h + 'px';
      drawOverlay();
    }
    addEventListener('resize', ()=>setTimeout(resizeOverlay,50));

    // ====== C√°mara
    async function startCamera(){
      try{
        state.stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'},audio:false});
        $video.srcObject = state.stream;
        await $video.play();
        state.running = true;
        state.usingImage = false;
        $imgPreview.style.display = 'none';
        $video.style.display = 'block';
        requestAnimationFrame(loop);
        setTimeout(resizeOverlay, 150);
      }catch(err){ console.error(err); }
    }
    function stopCamera(){
      state.running = false;
      if(state.stream){
        state.stream.getTracks().forEach(t=>t.stop());
        state.stream = null;
      }
    }

    // ====== Cargar imagen
    document.getElementById('file').addEventListener('change', async (e)=>{
      /*__cleared_rois_on_file_change__*/
      try{ clearAllRois && clearAllRois(); }catch(e){}

      const f = e.target.files?.[0]; if(!f) return;
      const url = URL.createObjectURL(f);
      $imgPreview.src = url;
      $imgPreview.onload = async ()=>{
        URL.revokeObjectURL(url);
        state.usingImage = true;
        $video.style.display='none';
        $imgPreview.style.display='block';
        const bmp = await imageBitmapFromImg($imgPreview);
        state.activeBitmap = bmp; state.activeNatural={w:bmp.width,h:bmp.height};
        resizeOverlay();
      };
    });

    // ====== Bucle principal
    let frames=0, lastFpsTs=0, lastDocPromptTs=0;
    async function loop(ts){
      if(!state.running) return;
      if(!$video.videoWidth){ requestAnimationFrame(loop); return; }

      frames++; if(ts-lastFpsTs>1000){
        const fps = Math.round(frames*1000/(ts-lastFpsTs));
        $fpsOverlay.textContent = fps+' fps';
        $fpsVal.textContent = fps; try{ var fTop=document.getElementById('fpsTop'); if(fTop) fTop.textContent=fps; }catch(e){}
        frames=0; lastFpsTs=ts;
      }

      const w=$video.videoWidth,h=$video.videoHeight;
      const bmp = await createImageBitmap($video, {resizeWidth:w,resizeHeight:h});
      state.activeBitmap = bmp; state.activeNatural={w,h};
      drawOverlay();

      // Auto-detect Doc (solo en draft y si hay modelo)
      if(state.phase==='draft' && state.docWorkerId && document.getElementById('chkAutoDoc').checked){
        try{
          const cvimg = new inferencejs.CVImage($video);
          const preds = await state.engine.infer(state.docWorkerId, cvimg);
          state.lastDocDetections = preds||[];
          drawOverlay();
          const best = _.maxBy(state.lastDocDetections, p=>p.confidence||0);
          if(best && (best.confidence||0) >= 0.65 && ts-lastDocPromptTs>1200){
            lastDocPromptTs = ts;
            confirmCapture(best);
          }
        }catch(e){ console.warn('infer doc error', e); }
      }

      requestAnimationFrame(loop);
    }

    // ====== Confirmar captura desde detecci√≥n doc
    async function confirmCapture(det){
      const ok = confirm('Se detect√≥ un documento con alta confianza. ¬øDeseas capturar esa regi√≥n?');
      if(!ok) return;
      const crop = cropFromDetection(det);
      await showPreviewBitmap(crop);
      runOCROnActive('Captura de documento');
    }

    function cropFromDetection(det){
      const {w:W,h:H} = state.activeNatural;
      const {x,y,width,height} = det.bbox;
      const x0 = Math.max(0, Math.round(x - width/2));
      const y0 = Math.max(0, Math.round(y - height/2));
      const ww = Math.min(W - x0, Math.round(width));
      const hh = Math.min(H - y0, Math.round(height));
      const off = new OffscreenCanvas(ww, hh);
      off.getContext('2d').drawImage(state.activeBitmap, x0, y0, ww, hh, 0, 0, ww, hh);
      return off.transferToImageBitmap();
    }

    async function showPreviewBitmap(bmp){
      const c = new OffscreenCanvas(bmp.width, bmp.height);
      const g = c.getContext('2d');
      g.drawImage(bmp,0,0);
      const blob = await c.convertToBlob({type:'image/png', quality:0.92});
      const url = URL.createObjectURL(blob);
      $imgPreview.src = url;
      $imgPreview.onload = ()=>{ URL.revokeObjectURL(url); };
      state.usingImage = true;
      $video.style.display='none';
      $imgPreview.style.display='block';
      state.activeBitmap = bmp; state.activeNatural={w:bmp.width,h:bmp.height};
      setTimeout(resizeOverlay, 100);
    }

    // ====== Dibujo overlay
    function drawOverlay(){
      const view = $overlay.getBoundingClientRect();
      const viewW = view.width, viewH = view.height;

      ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
      ctx.clearRect(0,0,$overlay.width,$overlay.height);

      // Detecciones de documento (solo draft)
      if(state.phase==='draft'){
        for(const p of state.lastDocDetections){
          const rect = bboxToOverlayRect(p.bbox);
          ctx.strokeStyle = '#5ac8fa';
          ctx.lineWidth = 2;
          ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
          ctx.fillStyle = 'rgba(90,200,250,.12)';
          ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
          ctx.fillStyle = '#cfe9fb';
          ctx.font = '12px ui-monospace';
          const tag = `${p.class||'doc'} ${(p.confidence||0).toFixed(2)}`;
          ctx.fillText(tag, rect.x+6, rect.y+14);
        }
      }

      // ROIs
      roisDraw({width:viewW, height:viewH});
    }

    function bboxToOverlayRect(bbox){
      const view = $overlay.getBoundingClientRect();
      const viewW = view.width, viewH = view.height;
      const natW = state.activeNatural.w || 1, natH = state.activeNatural.h || 1;
      const scale = Math.min(viewW/natW, viewH/natH);
      const offX = (viewW - natW*scale)/2, offY = (viewH - natH*scale)/2;
      const sx = offX + (bbox.x - bbox.width/2) * scale;
      const sy = offY + (bbox.y - bbox.height/2) * scale;
      const sw = bbox.width * scale, sh = bbox.height * scale;
      return {x:sx,y:sy,w:sw,h:sh};
    }

    // ====== ROI manager (dibujar, seleccionar, mover, redimensionar con 8 puntos)
    function roisDraw(view){
      for(const roi of state.rois){
        const x = roi.x*view.width, y=roi.y*view.height, w=roi.w*view.width, h=roi.h*view.height;
        const selected = (roi.id===state.selectedRoiId);

        ctx.strokeStyle = selected?'#34d399':'#9fb3c8';
        ctx.lineWidth = selected?2:1.5;
        ctx.strokeRect(x,y,w,h);
        if(selected){
          ctx.fillStyle='rgba(52,211,153,.07)';
          ctx.fillRect(x,y,w,h);
        }

        ctx.fillStyle='#cfe9fb';
        ctx.font='12px ui-monospace';
        ctx.fillText(`${roi.name||('ROI '+roi.id)} ¬∑ ${roi.type||'text'}`, x+6, y+14);

        if(selected){
          const H=10;
          const pts=[
            [x,y], [x+w/2-H/2,y], [x+w-H,y],
            [x+w-H,y+h/2-H/2], [x+w-H,y+h-H],
            [x+w/2-H/2,y+h-H], [x,y+h-H],
            [x,y+h/2-H/2]
          ];
          ctx.fillStyle='#5ac8fa';
          pts.forEach(([px,py])=>{
            ctx.fillRect(px,py,H,H);
            ctx.strokeStyle='#00121c'; ctx.lineWidth=1;
            ctx.strokeRect(px,py,H,H);
          });
        }
      }
    }

    function updateRoiCount(){ document.getElementById('roiCount').textContent = state.rois.length + ' ROIs'; }

    function syncRoiPropsPanel(){
      const a = state.rois.find(r=>r.id===state.selectedRoiId);
      const disabled = !a;
      [$roiName,$roiType,$roiX,$roiY,$roiW,$roiH].forEach(inp=>{ inp.disabled = disabled; });
      if(a){
        $roiName.value = a.name || '';
        $roiType.value = a.type || 'text';
        $roiX.value = a.x.toFixed(3);
        $roiY.value = a.y.toFixed(3);
        $roiW.value = a.w.toFixed(3);
        $roiH.value = a.h.toFixed(3);
      }else{
        $roiName.value=''; $roiType.value='text'; $roiX.value=''; $roiY.value=''; $roiW.value=''; $roiH.value='';
      }
    }

    function addRoiFromRect(px,py,pw,ph){
      const r = $overlay.getBoundingClientRect();
      const rx = px / r.width,  ry = py / r.height;
      const rw = pw / r.width,  rh = ph / r.height;

      const roi = {
        id: _.uniqueId('roi_'),
        name: 'ROI',
        type: 'text',
        x: Math.max(0, rx),
        y: Math.max(0, ry),
        w: Math.max(0.02, Math.min(1, rw)),
        h: Math.max(0.02, Math.min(1, rh))
      };
      state.rois.push(roi);
      state.selectedRoiId = roi.id;
      if(state.rois.length===1){ try{ if(typeof updateSteps==='function') updateSteps(3); }catch(e){} }
      updateRoiCount(); drawOverlay(); syncRoiPropsPanel();
      return roi;
    }

    function pickRoi(px,py){
      const r = $overlay.getBoundingClientRect();
      const rx = px / r.width, ry = py / r.height;
      for(let i=state.rois.length-1;i>=0;i--){
        const a=state.rois[i];
        if(rx>=a.x && ry>=a.y && rx<=a.x+a.w && ry<=a.y+a.h){ return a; }
      }
      return null;
    }

    function removeSelected(){
      if(!state.selectedRoiId) return;
      _.remove(state.rois, r=>r.id===state.selectedRoiId);
      state.selectedRoiId = null; updateRoiCount(); drawOverlay(); syncRoiPropsPanel();
    }

    // Interacci√≥n ROIs
    const drag = {mode:null, roi:null, origin:{x:0,y:0}, handle:null};
    function overlayPointFromEvent(e){
      const r = $overlay.getBoundingClientRect();
      const pt = (e.touches? e.touches[0]: e);
      const x = Math.min(Math.max(pt.clientX - r.left, 0), r.width);
      const y = Math.min(Math.max(pt.clientY - r.top,  0), r.height);
      return {x,y};
    }
    function handleAt(roi,px,py){
      const r = $overlay.getBoundingClientRect();
      const x = roi.x*r.width, y=roi.y*r.height, w=roi.w*r.width, h=roi.h*r.height;
      const H=12;
      const within=(ax,ay)=> px>=ax && py>=ay && px<=ax+H && py<=ay+H;
      if(within(x,y)) return 'nw';
      if(within(x+w/2-H/2,y)) return 'n';
      if(within(x+w-H,y)) return 'ne';
      if(within(x+w-H,y+h/2-H/2)) return 'e';
      if(within(x+w-H,y+h-H)) return 'se';
      if(within(x+w/2-H/2,y+h-H)) return 's';
      if(within(x,y+h-H)) return 'sw';
      if(within(x,y+h/2-H/2)) return 'w';
      return null;
    }
    function onDown(e){
      const pt = overlayPointFromEvent(e);
      const pick = pickRoi(pt.x,pt.y);
      if(pick){
        state.selectedRoiId = pick.id; drawOverlay(); syncRoiPropsPanel();
        const h = handleAt(pick, pt.x, pt.y);
        drag.mode = h? 'resize':'move'; drag.roi = _.cloneDeep(pick); drag.origin={x:pt.x,y:pt.y}; drag.handle=h; e.preventDefault();
      }else{
        drag.mode='new'; drag.origin={x:pt.x, y:pt.y}; drag.roi=null; e.preventDefault();
      }
    }
    function onMove(e){
      if(!drag.mode) return;
      const pt = overlayPointFromEvent(e); const dx=pt.x-drag.origin.x, dy=pt.y-drag.origin.y;
      const r = $overlay.getBoundingClientRect();

      if(drag.mode==='new'){
        drawOverlay();
        ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
        ctx.strokeStyle='#34d399'; ctx.lineWidth=2; ctx.setLineDash([6,6]);
        ctx.strokeRect(drag.origin.x, drag.origin.y, dx, dy);
        ctx.setLineDash([]);
      }
      if(drag.mode==='move' && drag.roi){
        const a = _.find(state.rois, {id: state.selectedRoiId}); if(!a) return;
        const rx = dx / r.width, ry = dy / r.height;
        a.x = _.clamp(drag.roi.x + rx, 0, 1 - a.w);
        a.y = _.clamp(drag.roi.y + ry, 0, 1 - a.h);
        drawOverlay(); syncRoiPropsPanel();
      }
      if(drag.mode==='resize' && drag.roi){
        const a = _.find(state.rois, {id: state.selectedRoiId}); if(!a) return;
        const rx = dx / r.width, ry = dy / r.height;
        let {x,y,w,h} = drag.roi;
        const hnd = drag.handle;
        if(hnd==='n'||hnd==='ne'||hnd==='nw'){ h = _.clamp(h - ry, 0.02, 1); y = _.clamp(y + ry, 0, y+h); }
        if(hnd==='s'||hnd==='se'||hnd==='sw'){ h = _.clamp(h + ry, 0.02, 1); }
        if(hnd==='w'||hnd==='nw'||hnd==='sw'){ w = _.clamp(w - rx, 0.02, 1); x = _.clamp(x + rx, 0, x+w); }
        if(hnd==='e'||hnd==='ne'||hnd==='se'){ w = _.clamp(w + rx, 0.02, 1); }
        a.x=x; a.y=y; a.w=w; a.h=h; drawOverlay(); syncRoiPropsPanel();
      }
      e.preventDefault();
    }
    function onUp(e){
      if(drag.mode==='new'){
        const pt = overlayPointFromEvent(e); const x=Math.min(drag.origin.x, pt.x); const y=Math.min(drag.origin.y, pt.y);
        const w=Math.abs(pt.x-drag.origin.x); const h=Math.abs(pt.y-drag.origin.y);
        if(w>10 && h>10) addRoiFromRect(x,y,w,h);
      }
      drag.mode=null; drag.roi=null; drag.handle=null;
    }
    $overlay.addEventListener('mousedown', onDown); $overlay.addEventListener('mousemove', onMove); $overlay.addEventListener('mouseup', onUp);
    $overlay.addEventListener('touchstart', onDown, {passive:false}); $overlay.addEventListener('touchmove', onMove, {passive:false}); $overlay.addEventListener('touchend', onUp);
    addEventListener('keydown', (e)=>{ if(e.key==='Delete' || e.key==='Backspace') removeSelected(); });

    
document.getElementById('btnDeleteRoi').addEventListener('click', ()=>{ removeSelected(); });

document.getElementById('btnClearRois').addEventListener('click', ()=>{ clearAllRois(); });
// Inputs/props ROI
    [$roiName,$roiType,$roiX,$roiY,$roiW,$roiH].forEach(inp=>{
      inp.addEventListener('input', ()=>{
        const a = state.rois.find(r=>r.id===state.selectedRoiId);
        if(!a) return;
        if(inp===$roiName){ a.name = $roiName.value; }
        else if(inp===$roiType){ a.type = $roiType.value; }
        else{
          const v = _.clamp(parseFloat(inp.value||'0')||0, 0, 1);
          if(inp===$roiX) a.x = v;
          if(inp===$roiY) a.y = v;
          if(inp===$roiW) a.w = Math.max(0.02, v);
          if(inp===$roiH) a.h = Math.max(0.02, v);
        }
        drawOverlay();
      });
    });
    syncRoiPropsPanel();

    // ====== Exportar / Importar plantilla ROIs
    document.getElementById('btnExport').addEventListener('click',()=>{
      const data = { schema:'roi-template:v1', size: state.activeNatural, rois: state.rois };
      const blob = new Blob([JSON.stringify(data,null,2)], {type:'application/json'});
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'plantilla-roi.json'; a.click();
      setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
    });
    document.getElementById('fileImport').addEventListener('change', async (e)=>{
      const f=e.target.files?.[0]; if(!f) return; const txt = await f.text();
      try{
        const j = JSON.parse(txt);
        if(j && Array.isArray(j.rois)) { try{ if(typeof updateSteps==='function') updateSteps(3); }catch(e){} ; state.rois = j.rois.map(r=>({type:'text',...r})); updateRoiCount(); drawOverlay(); syncRoiPropsPanel(); }
      }catch(err){ alert('JSON inv√°lido'); }
    });

    // ====== Botones principales
    document.getElementById('btnStart').addEventListener('click', startCamera);
    document.getElementById('btnStop').addEventListener('click', stopCamera);
    document.getElementById('btnShot').addEventListener('click', async ()=>{
      if(!$video.videoWidth && !$imgPreview.complete) return;
      const bmp = state.usingImage ? await imageBitmapFromImg($imgPreview) : await createImageBitmap($video);
      await showPreviewBitmap(bmp);
    });
    document.getElementById('btnShotDoc').addEventListener('click', async ()=>{
      if(!state.docWorkerId) return alert('Modelo de documento no listo (etapa borrador)');
      const preds = await state.engine.infer(state.docWorkerId, new inferencejs.CVImage($video));
      if(!preds?.length) return alert('No se detect√≥ documento');
      const best = _.maxBy(preds, p=>p.confidence||0);
      const bmp = await createImageBitmap($video);
      state.activeBitmap = bmp; state.activeNatural={w:bmp.width,h:bmp.height};
      const crop = cropFromDetection(best);
      await showPreviewBitmap(crop);
      runOCROnActive('Captura de documento');
    });

    document.getElementById('btnSetFinal').addEventListener('click', switchToFinalPhase);

    // Botones de carga/descarga manual
    document.getElementById('btnLoadDoc').addEventListener('click', loadDoc);
    document.getElementById('btnUnloadDoc').addEventListener('click', unloadDoc);
    document.getElementById('btnLoadMRZ').addEventListener('click', loadMRZ);
    document.getElementById('btnUnloadMRZ').addEventListener('click', unloadMRZ);
    document.getElementById('btnLoadPDF').addEventListener('click', loadPDF);
    document.getElementById('btnUnloadPDF').addEventListener('click', unloadPDF);

    // Capturar solo documento desde imagen cargada
    document.getElementById('btnShotDocImage').addEventListener('click', async ()=>{
      if(!state.usingImage){ return alert('Primero sube o muestra una imagen.'); }
      if(!state.docWorkerId){ return alert('Modelo de documento no cargado. Usa "Cargar Doc".'); }
      try{
        const preds = await state.engine.infer(state.docWorkerId, new inferencejs.CVImage($imgPreview));
        if(!preds?.length) return alert('No se detect√≥ documento en la imagen.');
        const best = _.maxBy(preds, p=>p.confidence||0);
        const crop = cropFromDetection(best);
        await showPreviewBitmap(crop);
        runOCROnActive('Documento (imagen cargada)');
      }catch(e){
        console.error(e); alert('Error al detectar documento en imagen.');
      }
    });


    // ====== MRZ/PDF (solo funcionan en fase final)
    $btnDetectMRZ.addEventListener('click', ()=>detectMRZFlow('Detecci√≥n manual'));
    $btnDetectPDF.addEventListener('click', ()=>detectPDF417Flow('Detecci√≥n manual'));

    async function detectMRZFlow(context=''){
      if(state.phase!=='final' || !state.mrzWorkerId) return alert('Modelo MRZ no listo');
      const host = state.usingImage ? $imgPreview : $video;
      if(!state.usingImage && !$video.videoWidth){ return alert('No hay imagen/c√°mara lista'); }
      setStatus(`Buscando MRZ‚Ä¶ ${context?'(' + context + ')':''}`);
      try{
        const preds = await state.engine.infer(state.mrzWorkerId, new inferencejs.CVImage(host));
        if(!preds?.length){ setStatus('No se detect√≥ MRZ.', true); return; }
        const best = _.maxBy(preds, p=>p.confidence||0);
        // Crear/actualizar ROI y extraer con OCR+parse
        const roi = ensureAutoRoiFromBbox(best, 'MRZ (auto)', 'mrz');
        await extractAndReportROI(roi, 'Detecci√≥n MRZ');
      }catch(e){
        console.error(e);
        setStatus('Error al inferir MRZ.', true);
      }
    }

    async function detectPDF417Flow(context=''){
      if(state.phase!=='final' || !state.pdfWorkerId) return alert('Modelo PDF417 no listo');
      const host = state.usingImage ? $imgPreview : $video;
      if(!state.usingImage && !$video.videoWidth){ return alert('No hay imagen/c√°mara lista'); }
      setStatus(`Buscando PDF417‚Ä¶ ${context?'(' + context + ')':''}`);
      try{
        const preds = await state.engine.infer(state.pdfWorkerId, new inferencejs.CVImage(host));
        if(!preds?.length){ setStatus('No se detect√≥ PDF417.', true); return; }
        const best = _.maxBy(preds, p=>p.confidence||0);
        const roi = ensureAutoRoiFromBbox(best, 'PDF417 (auto)', 'pdf417');
        await extractAndReportROI(roi, 'Detecci√≥n PDF417');
      }catch(e){
        console.error(e);
        setStatus('Error al inferir PDF417.', true);
      }
    }

    function ensureAutoRoiFromBbox(det, name, type){
      const rect = bboxToOverlayRect(det.bbox);
      const roi = addRoiFromRect(rect.x, rect.y, rect.w, rect.h);
      roi.name = name; roi.type = type;
      state.selectedRoiId = roi.id; syncRoiPropsPanel(); drawOverlay();
      return roi;
    }

    // ====== OCR + Parseo (imagen completa)
    document.getElementById('btnParseFull').addEventListener('click', ()=>{
      if(!state.usingImage){ alert('Primero sube una imagen o captura una'); return; }
      runOCROnActive('Imagen completa');
    });

    async function imageBitmapFromImg(img){
      const {naturalWidth:w, naturalHeight:h} = img; return await createImageBitmap(img, {resizeWidth:w, resizeHeight:h});
    }

    async function runOCROnActive(contextLabel){
      if(!state.activeBitmap){ alert('No hay imagen activa'); return; }
      setStatus(`Procesando OCR (${contextLabel})‚Ä¶`);
      const c = new OffscreenCanvas(state.activeBitmap.width, state.activeBitmap.height);
      const g = c.getContext('2d'); g.drawImage(state.activeBitmap,0,0);
      const blob = await c.convertToBlob({type:'image/png', quality:0.92});
      const imgUrl = URL.createObjectURL(blob);
      try{
        const worker = await Tesseract.createWorker('spa+eng');
        const { data:{ text } } = await worker.recognize(imgUrl);
        await worker.terminate();
        $raw.value = (text||'').trim();
        parseToTable($raw.value);
        setStatus('OCR completado.');
      }catch(err){ console.error(err); setStatus('Error en OCR', true); }
      finally{ URL.revokeObjectURL(imgUrl); }
    }

    // ====== ‚Äî‚Äî MRZ: Normalizaci√≥n & Parseo ======
    function normalizeRawMRZ(t){
      return t
        .replace(/[^\dA-Z<\n]/g,'')
        .replace(/[ \t]+/g,'')
        .toUpperCase()
        .trim();
    }
    function splitNames(s){
      const parts = s.split('<<');
      const surname = (parts[0]||'').replace(/</g,' ').trim();
      const given = (parts[1]||'').replace(/</g,' ').trim();
      return {surname, given};
    }
    function parseTD3(lines){
      const L1 = (lines[0]||'').padEnd(44,'<').slice(0,44);
      const L2 = (lines[1]||'').padEnd(44,'<').slice(0,44);
      const docType = L1.slice(0,2).replace(/</g,'');
      const issuer = L1.slice(2,5).replace(/</g,'');
      const namePart = L1.slice(5);
      const {surname, given} = splitNames(namePart);
      const passportNumber = L2.slice(0,9).replace(/</g,'');
      const nationality = L2.slice(10,13).replace(/</g,'');
      const birth = L2.slice(13,19);
      const sex = L2.slice(20,21).replace(/</g,'');
      const expiry = L2.slice(21,27);
      const personal = L2.slice(28,42).replace(/</g,'');
      return {
        Formato:'TD3 (Pasaporte)',
        'Tipo de documento':docType,
        'Pa√≠s emisor':issuer,
        'Apellidos':surname,
        'Nombres':given,
        'N√∫mero de documento':passportNumber,
        'Nacionalidad':nationality,
        'Fecha de nacimiento (YYMMDD)':birth,
        'Sexo':sex,
        'Fecha de expiraci√≥n (YYMMDD)':expiry,
        'N√∫mero personal':personal
      };
    }
    function parseTD1(lines){
      const L1 = (lines[0]||'').padEnd(30,'<').slice(0,30);
      const L2 = (lines[1]||'').padEnd(30,'<').slice(0,30);
      const L3 = (lines[2]||'').padEnd(30,'<').slice(0,30);
      const docType = L1.slice(0,2).replace(/</g,'');
      const country = L1.slice(2,5).replace(/</g,'');
      const number = L1.slice(5,14).replace(/</g,'');
      const birth = L2.slice(0,6);
      const sex = L2.slice(7,8);
      const expiry = L2.slice(8,14);
      const nationality = L2.slice(15,18).replace(/</g,'');
      const optional = L3.slice(0,30).replace(/</g,' ').trim();
      const {surname, given} = splitNames(L3);
      return {
        Formato:'TD1 (ID 3 l√≠neas)',
        'Tipo de documento':docType,
        'Pa√≠s emisor':country,
        'N√∫mero de documento':number,
        'Fecha de nacimiento (YYMMDD)':birth,
        'Sexo':sex,
        'Fecha de expiraci√≥n (YYMMDD)':expiry,
        'Nacionalidad':nationality,
        'Apellidos':surname,
        'Nombres':given,
        'Dato opcional':optional
      };
    }
    function parseTD2(lines){
      const L1 = (lines[0]||'').padEnd(36,'<').slice(0,36);
      const L2 = (lines[1]||'').padEnd(36,'<').slice(0,36);
      const docType = L1.slice(0,2).replace(/</g,'');
      const country = L1.slice(2,5).replace(/</g,'');
      const namePart = L1.slice(5);
      const {surname, given} = splitNames(namePart);
      const number = L2.slice(0,9).replace(/</g,'');
      const nationality = L2.slice(10,13).replace(/</g,'');
      const birth = L2.slice(13,19);
      const sex = L2.slice(20,21);
      const expiry = L2.slice(21,27);
      const optional = L2.slice(28,35).replace(/</g,' ').trim();
      return {
        Formato:'TD2 (ID 2 l√≠neas)',
        'Tipo de documento':docType,
        'Pa√≠s emisor':country,
        'Apellidos':surname,
        'Nombres':given,
        'N√∫mero de documento':number,
        'Nacionalidad':nationality,
        'Fecha de nacimiento (YYMMDD)':birth,
        'Sexo':sex,
        'Fecha de expiraci√≥n (YYMMDD)':expiry,
        'Dato opcional':optional
      };
    }
    function guessAndParseMRZ(raw){
      const text = normalizeRawMRZ(raw);
      const lines = text.split(/\n+/).map(s=>s.trim()).filter(Boolean);
      if(lines.length>=2 && lines.every(l=>l.length>=36)){
        const L = lines.map(l=>l.replace(/\s+/g,''));
        if(L[0].length>=44 || L[1].length>=44) return parseTD3([L[0].slice(0,44), L[1].slice(0,44)]);
        return parseTD2([L[0].slice(0,36), L[1].slice(0,36)]);
      }else if(lines.length>=3){
        const L = lines.slice(0,3).map(l=>l.replace(/\s+/g,''));
        return parseTD1([L[0].slice(0,30), L[1].slice(0,30), L[2].slice(0,30)]);
      }else{
        throw new Error('No se reconoce el formato MRZ.');
      }
    }

    // ====== Fechas MRZ ‚Üí ISO + edad y vencimiento
    function yyMMddToISO(yyMMdd){
      if(!/^\d{6}$/.test(yyMMdd)) return null;
      const yy = parseInt(yyMMdd.slice(0,2),10);
      const mm = parseInt(yyMMdd.slice(2,4),10);
      const dd = parseInt(yyMMdd.slice(4,6),10);
      const year = (yy >= 50 ? 1900 : 2000) + yy;
      if(mm<1||mm>12||dd<1||dd>31) return null;
      const m = String(mm).padStart(2,'0');
      const d = String(dd).padStart(2,'0');
      return `${year}-${m}-${d}`;
    }
    function isoToDate(iso){ const d = new Date(iso+'T00:00:00'); return isNaN(d.getTime()) ? null : d; }
    function yearsBetween(birthISO){
      const d = isoToDate(birthISO); if(!d) return null;
      const now = new Date();
      let age = now.getFullYear() - d.getFullYear();
      const m = now.getMonth() - d.getMonth();
      if(m < 0 || (m === 0 && now.getDate() < d.getDate())) age--;
      return age;
    }
    function daysUntilISO(iso){
      const d = isoToDate(iso); if(!d) return null;
      const now = new Date();
      const msPerDay = 24*60*60*1000;
      return Math.ceil((d - new Date(now.getFullYear(), now.getMonth(), now.getDate())) / msPerDay);
    }
    function augmentMRZ(parsed){
      const out = {...parsed};
      const kBirth = 'Fecha de nacimiento (YYMMDD)';
      const kExp   = 'Fecha de expiraci√≥n (YYMMDD)';
      if(parsed[kBirth]){
        const iso = yyMMddToISO(parsed[kBirth]); if(iso){
          out['Fecha de nacimiento'] = iso;
          const age = yearsBetween(iso); if(age!=null) out['Edad (a√±os)'] = String(age);
        }
      }
      if(parsed[kExp]){
        const iso = yyMMddToISO(parsed[kExp]); if(iso){
          out['Fecha de expiraci√≥n'] = iso;
          const left = daysUntilISO(iso);
          if(left!=null){ out['D√≠as hasta expiraci√≥n'] = String(left); out['¬øVencido?'] = left < 0 ? 'S√≠' : 'No'; }
        }
      }
      return out;
    }

    // ====== √Årea "Texto crudo OCR"
    document.getElementById('btnParseRaw').addEventListener('click', ()=>{
      const txt = ($raw.value||'').trim();
      if(!txt){ setStatus('No hay texto para parsear.', true); return; }
      parseToTable(txt);
      setStatus('Texto crudo parseado.');
    });

    function renderPairsTo(tableEl, obj){
      let html = '<div class="scroll-wrap"><table class="result-table"><thead><tr><th>Campo</th><th>Valor</th></tr></thead><tbody>';
      for (const [k,v] of Object.entries(obj)){
        const vv = (v ?? '') === '' ? '<span class="muted">‚Äî</span>' : escapeHtml(String(v));
        html += `<tr><td><strong>${escapeHtml(k)}</strong></td><td>${vv}</td></tr>`;
      }
      html += '</tbody></table></div>';
      tableEl.innerHTML = html;
    }

    function parseToTable(raw){
      // Primero MRZ
      try{
        const parsed = guessAndParseMRZ(raw);
        const enriched = augmentMRZ(parsed);
        mrzSummary.classList.remove('hidden');
        mrzSummary.innerHTML = "<strong>Resultados</strong> ‚Äî <span class='ok'>MRZ parseado.</span>";
        renderPairsTo(mrzTable, enriched);
        addRoiResult({name:'(Texto crudo)', type:'text'}, enriched);
        return;
      }catch(_){}
      // Si no es MRZ, intentar pares key:value
      const rows = {};
      const lines = raw.split(/\r?\n+/).map(s=>s.trim()).filter(Boolean);
      for(const ln of lines){
        const m = ln.match(/^([^:]{2,48})\s*:\s*(.+)$/);
        if(m) rows[m[1].trim()] = m[2].trim();
      }
      if(Object.keys(rows).length===0){
        lines.slice(0,50).forEach((v,i)=>rows[`L√≠nea ${i+1}`]=v);
      }
      mrzSummary.classList.remove('hidden');
      mrzSummary.innerHTML = "<strong>Resultados</strong> ‚Äî <span class='warn'>Texto gen√©rico (no MRZ).</span>";
      renderPairsTo(mrzTable, rows);
      addRoiResult({name:'(Texto crudo)', type:'text'}, rows);
    }

    // ====== Extracci√≥n por ROI
    document.getElementById('btnExtractSelected').addEventListener('click', async ()=>{
      const a = state.rois.find(r=>r.id===state.selectedRoiId);
      if(!a) return alert('Selecciona un ROI');
      await extractAndReportROI(a);
    });
    document.getElementById('btnExtractAll').addEventListener('click', async ()=>{
      if(!state.rois.length) return alert('No hay ROIs');
      for(const r of state.rois){ await extractAndReportROI(r); }
      setStatus('Extracci√≥n de todos los ROIs finalizada.');
    });

    async function extractAndReportROI(roi, originLabel=''){
      if(!state.activeBitmap){ alert('No hay imagen activa'); return; }
      const cnv = roiToCanvas(roi);
      const dataUrl = await canvasToBlobUrl(cnv);
      try{
        switch((roi.type||'text').toLowerCase()){
          case 'image':{
            addRoiResult(roi, {'Imagen exportada': (roi.name||roi.id)+'.png'});
            const a = document.createElement('a'); a.href = dataUrl; a.download = `${(roi.name||roi.id)}.png`; a.click();
            setStatus(`Imagen ROI "${roi.name||roi.id}" exportada.`);
            break;
          }
          case 'text':{
            const text = await ocrCanvas(cnv, 'spa+eng');
            $raw.value = text || '';
            parseToTable($raw.value);
            addRoiResult(roi, {'Texto': text||''});
            setStatus(`Texto extra√≠do de "${roi.name||roi.id}".`);
            break;
          }
          case 'mrz':{
            const text = await ocrCanvas(cnv, 'eng');
            $raw.value = text || '';
            try{
              const parsed = guessAndParseMRZ(text||'');
              const enriched = augmentMRZ(parsed);
              mrzSummary.classList.remove('hidden');
              mrzSummary.innerHTML = "<strong>Resultados</strong> ‚Äî <span class='ok'>MRZ parseado.</span>";
              renderPairsTo(mrzTable, enriched);
              addRoiResult(roi, enriched);
              setStatus(`MRZ parseado en "${roi.name||roi.id}".`);
            }catch(e){
              mrzSummary.classList.remove('hidden');
              mrzSummary.innerHTML = "<strong>Resultados</strong> ‚Äî <span class='err'>MRZ no reconocido.</span>";
              renderPairsTo(mrzTable, {'raw': (text||'(vac√≠o)')});
              addRoiResult(roi, {'raw': text||'(vac√≠o)'});
              setStatus(`MRZ no reconocido en "${roi.name||roi.id}".`, true);
            }
            break;
          }
          case 'pdf417':{
            const res = await decodeBarcodeWithZXing(dataUrl, ['PDF_417']);
            if(res){
              tryAutoParseDUIFromPDF417(res); // pinta arriba (PDF417)
              const rawPDF = (extractRawTextFromPdf417(res) || '').trim();
              const parsed = parseDUIFromRaw(rawPDF);
              if(parsed && parsed.fields){
                addRoiResult(roi, parsed.fields);
              }else{
                addRoiResult(roi, {'Texto PDF417': rawPDF||'(vac√≠o)'});
              }
              $raw.value = rawPDF;
              setStatus(`PDF417 decodificado en "${roi.name||roi.id}".`);
            }else{
              pdf417Error.classList.remove('hidden');
              pdf417Error.textContent = 'PDF417 Error: No se pudo decodificar.';
              pdf417Table.innerHTML = '<p class="muted">No se pudo decodificar PDF417.</p>';
              addRoiResult(roi, {'Error': 'No se pudo decodificar PDF417'});
              setStatus(`PDF417 no encontrado en "${roi.name||roi.id}".`, true);
            }
            break;
          }
          case 'barcode':{
            const res = await decodeBarcodeWithZXing(dataUrl, 'ALL');
            if(res){
              const txt = (res.getText? res.getText(): (res.text||'')) || '';
              const fmt = (res.getBarcodeFormat? res.getBarcodeFormat(): (res.format||'‚Äî'));
              $raw.value = txt.trim();
              parseToTable($raw.value);
              addRoiResult(roi, {'Formato': fmt, 'Texto': txt});
              setStatus(`C√≥digo de barras le√≠do (${fmt}) en "${roi.name||roi.id}".`);
            }
            else {
              addRoiResult(roi, {'Error': 'No se pudo leer c√≥digo'});
              setStatus(`No se pudo leer c√≥digo en "${roi.name||roi.id}".`, true);
            }
            break;
          }
          default:{
            addRoiResult(roi, {'Error': `Tipo no soportado: ${roi.type}`});
            setStatus(`Tipo no soportado: ${roi.type}`, true);
          }
        }
      }finally{
        URL.revokeObjectURL(dataUrl);
      }
    }

    // ====== Tabla de Resultados (ROIs) ‚Äî crear/limpiar/exportar
    function ensureRoiResultsTable(){
      if(document.getElementById('roiResultsTable')) return;
      roiResults.innerHTML = `
        <table id="roiResultsTable" class="result-table">
          <thead>
            <tr><th>ROI</th><th>Tipo</th><th>Campo</th><th>Valor</th></tr>
          </thead>
          <tbody id="roiResultsBody"></tbody>
        </table>`;
    }
    function addRoiResult(roi, data){
      ensureRoiResultsTable();
      const body = document.getElementById('roiResultsBody');
      const roiName = escapeHtml(roi?.name || roi?.id || '(ROI)');
      const roiType = escapeHtml((roi?.type || 'text').toLowerCase());

      if(data && typeof data === 'object' && !Array.isArray(data)){
        for(const [k,v] of Object.entries(data)){
          const tr = document.createElement('tr');
          tr.innerHTML = `<td>${roiName}</td><td>${roiType}</td><td><strong>${escapeHtml(k)}</strong></td><td>${escapeHtml(String(v))}</td>`;
          body.appendChild(tr);
        }
      }else{
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${roiName}</td><td>${roiType}</td><td><strong>Texto</strong></td><td>${escapeHtml(String(data||''))}</td>`;
        body.appendChild(tr);
      }
    }
    function clearRoiResults(){
      const tbl = document.getElementById('roiResultsTable');
      if(tbl){ const body = document.getElementById('roiResultsBody'); if(body) body.innerHTML=''; }
      else ensureRoiResultsTable();
    }
function clearAllRois(){
  try{
    if(Array.isArray(state.rois)) state.rois.length = 0;
    state.selectedRoiId = null;
  }catch(e){ console.warn('clearAllRois state reset warn:', e); }
  try{ updateRoiCount && updateRoiCount(); }catch(e){}
  try{ syncRoiPropsPanel && syncRoiPropsPanel(); }catch(e){}
  try{ clearRoiResults && clearRoiResults(); }catch(e){}
  try{ drawOverlay && drawOverlay(); }catch(e){}
  setStatus && setStatus('ROIs limpiados.');
}

    document.getElementById('btnRoiClear').addEventListener('click', clearRoiResults);

    document.getElementById('btnRoiCSV').addEventListener('click', ()=>{
      const rows = collectRoiRows();
      if(!rows.length){ alert('No hay datos para exportar'); return; }
      const headers = ['ROI','Tipo','Campo','Valor'];
      const csv = [headers.join(',')].concat(rows.map(r=>headers.map(h=>csvEsc(r[h])).join(','))).join('\n');
      const blob = new Blob([csv], {type:'text/csv;charset=utf-8'});
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'tabla-rois.csv'; a.click();
      setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
    });
    document.getElementById('btnRoiJSON').addEventListener('click', ()=>{
      const rows = collectRoiRows();
      if(!rows.length){ alert('No hay datos para exportar'); return; }
      const blob = new Blob([JSON.stringify(rows,null,2)], {type:'application/json'});
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'tabla-rois.json'; a.click();
      setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
    });
    function collectRoiRows(){
      const body = document.getElementById('roiResultsBody'); if(!body) return [];
      const out = [];
      [...body.querySelectorAll('tr')].forEach(tr=>{
        const tds = tr.querySelectorAll('td');
        if(tds.length>=4){
          out.push({ROI:tds[0].textContent||'', Tipo:tds[1].textContent||'', Campo:tds[2].innerText||'', Valor:tds[3].innerText||''});
        }
      });
      return out;
    }
    function csvEsc(s){
      s = String(s??'');
      return /[",\n]/.test(s) ? `"${s.replace(/"/g,'""')}"` : s;
    }

    // ====== ROI ‚Üí p√≠xeles naturales y utilidades
    function mapRoiToNatural(roi){
      const view = $overlay.getBoundingClientRect();
      const viewW = view.width, viewH = view.height;
      const natW = state.activeNatural.w, natH = state.activeNatural.h;
      if(!natW || !natH) return {x:0,y:0,w:0,h:0};
      const scale = Math.min(viewW/natW, viewH/natH);
      const contentW = natW * scale, contentH = natH * scale;
      const offX = (viewW - contentW)/2, offY = (viewH - contentH)/2;
      const ox = roi.x*viewW, oy = roi.y*viewH, ow = roi.w*viewW, oh = roi.h*viewH;
      const nx = Math.round((ox - offX)/scale);
      const ny = Math.round((oy - offY)/scale);
      const nw = Math.round(ow/scale);
      const nh = Math.round(oh/scale);
      const x = Math.max(0, Math.min(natW, nx));
      const y = Math.max(0, Math.min(natH, ny));
      const w = Math.max(1, Math.min(natW - x, nw));
      const h = Math.max(1, Math.min(natH - y, nh));
      return {x,y,w,h};
    }

    function roiToCanvas(roi){
      const {x,y,w,h} = mapRoiToNatural(roi);
      const off = new OffscreenCanvas(w,h);
      const g = off.getContext('2d');
      g.drawImage(state.activeBitmap, x,y,w,h, 0, 0, w, h);
      return off;
    }

    async function canvasToBlobUrl(cnv, type='image/png', quality=0.92){
      const blob = await cnv.convertToBlob({type, quality});
      return URL.createObjectURL(blob);
    }

    async function ocrCanvas(cnv, langs='spa+eng'){
      const url = await canvasToBlobUrl(cnv);
      try{
        const worker = await Tesseract.createWorker(langs);
        const { data:{ text } } = await worker.recognize(url);
        await worker.terminate();
        return (text||'').trim();
      }catch(e){ console.error(e); return ''; }
      finally{ URL.revokeObjectURL(url); }
    }

    async function decodeBarcodeWithZXing(dataUrl, formats='ALL'){
      const img = await dataUrlToImage(dataUrl);
      try{
        if(formats==='ALL'){
          const reader = new ZXing.BrowserMultiFormatReader();
          const res = await reader.decodeFromImage(img).catch(()=>null);
          return res ? {getText: ()=>res.getText(), getBarcodeFormat: ()=>String(res.getBarcodeFormat())} : null;
        }else if(Array.isArray(formats) && formats.includes('PDF_417')){
          const pdfReader = new ZXing.BrowserPDF417Reader();
          let res = null;
          try{ res = await pdfReader.decodeOnce(img); }
          catch{ res = await pdfReader.decodeFromImage(img); }
          return res ? {getText: ()=>res.getText(), getBarcodeFormat: ()=> 'PDF_417'} : null;
        }
        return null;
      }catch(e){
        console.warn('ZXing decode error', e);
        return null;
      }
    }

    function dataUrlToImage(url){
      return new Promise((resolve,reject)=>{
        const img = new Image();
        img.onload = ()=>resolve(img);
        img.onerror = reject;
        img.src = url;
      });
    }

    function escapeHtml(s){ return String(s).replace(/[&<>"']/g, m=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"})[m]); }

    // ====== PDF417: Procesar imagen actual (si quieres reutilizarlo manualmente)
    async function processPDF417(){
      pdf417Error.classList.add('hidden');
      try{
        await ensureImageLoaded($imgPreview);
        const reader = new ZXing.BrowserPDF417Reader();
        let result = null;
        try{
          result = await reader.decodeFromImageElement($imgPreview);
        }catch(e1){
          const canvas = document.createElement('canvas');
          const ctx2 = canvas.getContext('2d');
          canvas.width = $imgPreview.naturalWidth || $imgPreview.width;
          canvas.height = $imgPreview.naturalHeight || $imgPreview.height;
          if (!canvas.width || !canvas.height) throw e1;
          ctx2.drawImage($imgPreview, 0, 0, canvas.width, canvas.height);
          result = await reader.decodeFromCanvas(canvas);
        }
        tryAutoParseDUIFromPDF417(result);
      }catch(err){
        pdf417Error.classList.remove('hidden');
        pdf417Error.textContent = 'PDF417 Error: ' + (err?.message || err);
        pdf417Table.innerHTML = '<p class="muted">No se pudo decodificar PDF417.</p>';
      }
    }
    function ensureImageLoaded(img){
      return new Promise((resolve, reject)=>{
        if (img.complete && img.naturalWidth > 0) return resolve();
        img.onload = ()=> resolve();
        img.onerror = (e)=> reject(e);
      });
    }

    // ========= DUI Auto-Parse (desde texto de PDF417) =========
    let currentDuiRawText = null;
    let currentDuiJSON = null;

    function tryAutoParseDUIFromPDF417(resultObj){
      const rawText = extractRawTextFromPdf417(resultObj);
      currentDuiRawText = rawText || null;

      if (!rawText){
        pdf417Summary.classList.add('hidden');
        pdf417Table.innerHTML = '<p class="muted">No se encontr√≥ Texto crudo del PDF417 para parsear.</p>';
        currentDuiJSON = null;
        return;
      }

      const parsed = parseDUIFromRaw(rawText);
      if (!parsed){
        pdf417Summary.classList.add('hidden');
        pdf417Table.innerHTML = '<p class="muted">El Texto crudo no coincide con el formato esperado (separado por <code>||</code>).</p>';
        currentDuiJSON = null;
        return;
      }

      currentDuiJSON = parsed.toJSON;
      pdf417Summary.classList.remove('hidden');
      pdf417Summary.innerHTML = "<strong>Resultados</strong> ‚Äî <span class='ok'>DUI (PDF417 imagen) parseado.</span>";
      pdf417Table.innerHTML = renderKVTable(parsed.fields);
    }

    function extractRawTextFromPdf417(obj){
      try{
        if (!obj) return null;

        if (typeof obj.getText === 'function'){
          const t = obj.getText();
          if (t && typeof t === 'string' && t.trim()) return t.trim();
        }
        if (typeof obj === 'string'){
          try { obj = JSON.parse(obj); } catch(e){
            if (obj.includes('||')) return obj.trim();
            return null;
          }
        }
        if (Array.isArray(obj)){
          for (const it of obj){
            const t = extractRawTextFromPdf417(it);
            if (t) return t;
          }
        }
        const candidates = [
          obj?.text, obj?.Text, obj?.rawText, obj?.RawText,
          obj?.result?.text, obj?.result?.Text, obj?.result?.rawText,
          obj?.[0]?.text, obj?.[0]?.Text, obj?.[0]?.rawText
        ];
        for (const c of candidates){
          if (typeof c === 'string' && c.trim()) return c.trim();
        }
        for (const k of Object.keys(obj)){
          const v = obj[k];
          if (typeof v === 'string' && v.includes('||')) return v.trim();
        }
      }catch(e){ console.warn('extractRawTextFromPdf417 error:', e); }
      return null;
    }

    function parseDUIFromRaw(raw){
      if (!raw || typeof raw !== 'string') return null;
      const parts = raw.split('||');
      if (parts.length < 17) return null;

      const FIELDS = [
        'N√∫mero de DUI',
        'Primer Apellido',
        'Segundo Apellido y Nombres',
        'N√∫mero de Emisi√≥n',
        'Firma Digital',
        'Lugar de Nacimiento',
        'Municipio',
        'Profesi√≥n u Oficio',
        'Sexo',
        'Fecha de Nacimiento',
        'Fecha de Emisi√≥n',
        'C√≥digo de Zona',
        'Categor√≠a',
        'Estdo Familiar',
        'Nacionalidad',
        'Segunda Firma Digital',
        'C√≥digo de Verificaci√≥n'
      ];

      const obj = {};
      FIELDS.forEach((name, idx)=>{ obj[name] = (parts[idx] ?? '').trim(); });

      return {
        fields: obj,
        toJSON: obj,
        raw
      };
    }

    function renderKVTable(obj){
      let html = '<div class="scroll-wrap">';
      html += '<table class="result-table"><thead><tr><th>Campo</th><th>Valor</th></tr></thead><tbody>';
      for (const [k,v] of Object.entries(obj)){
        const vv = (v ?? '') === '' ? '<span class="muted">‚Äî</span>' : escapeHtml(String(v));
        html += `<tr><td><strong>${escapeHtml(k)}</strong></td><td>${vv}</td></tr>`;
      }
      html += '</tbody></table></div>';
      return html;
    }

    // ====== Utilidades varias
    async function canvasToBlobUrl(cnv, type='image/png', quality=0.92){
      const blob = await cnv.convertToBlob({type, quality});
      return URL.createObjectURL(blob);
    }

    function ensureRoiResultsTableIfEmpty(){ ensureRoiResultsTable(); }

    function escapeHtml(s){ return String(s).replace(/[&<>"']/g, m=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"})[m]); }

    // ====== Inicio
    (async function init(){
      await initEngine();       // solo Doc
      await startCamera();
      resizeOverlay();
      syncRoiPropsPanel();
      updateRoiCount();
      ensureRoiResultsTableIfEmpty();
      try{ if(typeof updateSteps==='function') updateSteps(1); }catch(e){}
    })();
  </script>

<script>
// === Default to DOC model active (borrador) without altering other logic ===
(function(){
  function tryLoadDocDefault(){
    try {
      if (window.state && window.state.engine && !window.state?.docWorkerId){
        if (typeof loadDocModelOnly === 'function'){
          loadDocModelOnly().finally(()=>{ if (typeof updateTopStatus==='function') updateTopStatus(); });
          return true;
        }
      }
    } catch(e){ console.warn(e); }
    return false;
  }
  if (document.readyState === 'complete' || document.readyState === 'interactive'){
    setTimeout(tryLoadDocDefault, 0);
  } else {
    document.addEventListener('DOMContentLoaded', tryLoadDocDefault, {once:true});
  }
})();

    // ====== UX Helpers: Tabs ======
    const tabButtons = Array.from(document.querySelectorAll('.tab-btn'));
    const tabPanels  = Array.from(document.querySelectorAll('[data-tab-panel]'));
    function showTab(id){
      tabButtons.forEach(b=>b.classList.toggle('active', b.dataset.tab===id));
      tabPanels.forEach(p=>p.style.display = (p.getAttribute('data-tab-panel')===id)?'block':'none');
      localStorage.setItem('ux.activeTab', id);
    }
    const lastTab = localStorage.getItem('ux.activeTab') || 'pdf417';
    showTab(lastTab);
    tabButtons.forEach(b=>b.addEventListener('click', ()=>showTab(b.dataset.tab)));

    // Copiar / Limpiar visible
    document.getElementById('btnCopyVisible').addEventListener('click', ()=>{
      const active = document.querySelector('[data-tab-panel][style*="block"]') || document.querySelector('[data-tab-panel]');
      if(!active) return;
      const txt = active.innerText || '';
      navigator.clipboard.writeText(txt).then(()=> showToast('Copiado al portapapeles'), ()=> showToast('No se pudo copiar', 'err'));
    });
    document.getElementById('btnClearVisible').addEventListener('click', ()=>{
      const id = (document.querySelector('.tab-btn.active')||{}).dataset?.tab || 'pdf417';
      if(id==='pdf417'){ pdf417Summary.innerHTML=''; pdf417Error.classList.add('hidden'); pdf417Table.innerHTML='<p class="muted">Sin datos.</p>'; }
      else if(id==='mrz'){ mrzSummary.innerHTML=''; mrzTable.innerHTML='<p class="muted">Sin datos.</p>'; }
      else if(id==='rois'){ clearRoiResults(); }
      else if(id==='raw'){ $raw.value=''; }
      showToast('Panel limpiado');
    });

    // ====== UX Helpers: Toasts ======
    function showToast(msg, kind=''){
      try{
        const host = document.getElementById('toastHost'); if(!host) return;
        const d = document.createElement('div'); d.className='toast'+(kind?(' '+kind):''); d.textContent=msg;
        host.appendChild(d);
        setTimeout(()=>{ d.style.opacity='0'; d.style.transition='opacity .3s'; }, 2500);
        setTimeout(()=>{ d.remove(); }, 3000);
      }catch(e){}
    }

    // Hook setStatus to also toast on errors/warns
    const _setStatus = setStatus;
    setStatus = function(msg,isErr){
      _setStatus(msg,isErr);
      if(isErr) showToast(String(msg||'Error'), 'err');
    }

    // ====== Ayuda Modal y atajos ======
    const dlgHelp = document.getElementById('dlgHelp');
    document.getElementById('btnHelp').addEventListener('click', ()=> dlgHelp.showModal());
    document.getElementById('btnHelpClose').addEventListener('click', ()=> dlgHelp.close());
    addEventListener('keydown', (e)=>{
      if(e.key==='?'){ e.preventDefault(); (dlgHelp.open? dlgHelp.close(): dlgHelp.showModal()); }
      else if(e.key==='s' || e.key==='S'){ document.getElementById('btnStart').click(); }
      else if(e.key==='x' || e.key==='X'){ document.getElementById('btnStop').click(); }
      else if(e.key==='c' || e.key==='C'){ document.getElementById('btnShot').click(); }
      else if(e.key==='d' || e.key==='D'){ document.getElementById('btnShotDoc').click(); }
      else if(e.key==='m' || e.key==='M'){ document.getElementById('btnDetectMRZ').click(); }
      else if(e.key==='p' || e.key==='P'){ document.getElementById('btnDetectPDF').click(); }
    });

    // ====== Preferencias (persistencia) ======
    const chkPersist = document.getElementById('chkPersist');
    chkPersist.checked = localStorage.getItem('ux.persist')==='1';
    chkPersist.addEventListener('change', ()=>{
      localStorage.setItem('ux.persist', chkPersist.checked ? '1':'0');
      showToast(chkPersist.checked?'Preferencias guardadas':'Preferencias no persistir√°n');
    });
    // Guardar/restaurar autodetect y ancho del panel si persist est√° activo
    const chkAutoDoc = document.getElementById('chkAutoDoc');
    if(localStorage.getItem('ux.persist')==='1'){
      const savedAuto = localStorage.getItem('ux.autoDoc'); if(savedAuto!=null) chkAutoDoc.checked = savedAuto==='1';
    }
    chkAutoDoc.addEventListener('change', ()=>{
      if(localStorage.getItem('ux.persist')==='1'){ localStorage.setItem('ux.autoDoc', chkAutoDoc.checked?'1':'0'); }
    });

    // ====== Resizer lateral ======
    (function(){
      const left = document.getElementById('leftPanel'); const handle = document.getElementById('resizeHandle');
      let dragging=false, startX=0, startW=0;
      function px(n){ return n+'px'; }
      function onDown(e){ dragging=true; startX = (e.touches?e.touches[0].clientX:e.clientX); startW = left.offsetWidth; e.preventDefault(); }
      function onMove(e){ if(!dragging) return; const x = (e.touches?e.touches[0].clientX:e.clientX); const dx=x-startX; const w=Math.max(260, Math.min(560, startW+dx)); left.style.width=px(w); if(localStorage.getItem('ux.persist')==='1'){ localStorage.setItem('ux.leftW', String(w)); } }
      function onUp(){ dragging=false; }
      handle.addEventListener('mousedown', onDown); handle.addEventListener('touchstart', onDown, {passive:false});
      addEventListener('mousemove', onMove, {passive:false}); addEventListener('touchmove', onMove, {passive:false});
      addEventListener('mouseup', onUp); addEventListener('touchend', onUp);
      // Restore
      if(localStorage.getItem('ux.persist')==='1'){
        const w = parseInt(localStorage.getItem('ux.leftW')||'0',10); if(w>0) left.style.width=px(w);
      }
    })();

    // ====== Spinners en acciones largas ======
    function withSpinner(btn, fn){
      return async function(...args){
        const old = btn.innerHTML;
        btn.innerHTML = '<span class="spin"></span> '+btn.textContent;
        btn.disabled = true;
        try{ return await fn.apply(this, args); }
        finally{ btn.disabled=false; btn.innerHTML = old; }
      }
    }
    // Aplicar a botones intensivos
    document.getElementById('btnShotDoc').onclick = withSpinner(document.getElementById('btnShotDoc'), document.getElementById('btnShotDoc').onclick || (async()=>{}));
    document.getElementById('btnDetectMRZ').onclick = withSpinner(document.getElementById('btnDetectMRZ'), ()=>detectMRZFlow('Detecci√≥n manual'));
    document.getElementById('btnDetectPDF').onclick = withSpinner(document.getElementById('btnDetectPDF'), ()=>detectPDF417Flow('Detecci√≥n manual'));
    document.getElementById('btnParseFull').onclick = withSpinner(document.getElementById('btnParseFull'), document.getElementById('btnParseFull').onclick || (async()=>{}));

    // ====== Mover badges de estado al Top ======
    (function(){
      function move(id, holderId){
        const el = document.getElementById(id);
        const holder = document.getElementById(holderId);
        if(el && holder){ holder.replaceWith(el); }
      }
      move('sEngine','sEngineHolder');
      move('sModelDoc','sModelDocHolder');
      move('sModelMRZ','sModelMRZHolder');
      move('sModelPDF','sModelPDFHolder');
      // Ocultar el bloque original "Estado" en el panel izquierdo
      try{
        const left = document.querySelector('aside.left');
        const bars = Array.from(left.querySelectorAll('.bar'));
        const b = bars.find(x=> (x.querySelector('h2')||{}).textContent?.trim()==='Estado');
        if(b) b.style.display='none';
      }catch(e){}
    })();
</script>

</body>
</html>
