<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>OCR de Documentos (Cámara + Imagen) · ROIs · Dark Mode</title>

  <!-- ====== Librerías por CDN ====== -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/inferencejs@1.1.3"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
  <!-- ZXing (barcodes, PDF417, etc.) -->
  <script src="https://unpkg.com/@zxing/library@latest"></script>

  <style>
    :root{--bg:#0b0f14;--panel:#111820;--muted:#1a2230;--text:#e6eef7;--sub:#9fb3c8;--accent:#5ac8fa;--good:#34d399;--bad:#f87171;--warn:#fbbf24;--border:#1f2a3a}
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;padding:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji"}
    h1{font-size:1.1rem;margin:0 0 .25rem 0;color:var(--text)}
    .app{display:grid;grid-template-columns:360px 1fr;gap:12px;height:100%;}
    .left{padding:12px;background:var(--panel);border-right:1px solid var(--border);overflow:auto}
    .right{display:grid;grid-template-rows:auto 1fr auto auto;gap:12px;padding:12px}

    .bar{display:flex;flex-wrap:wrap;align-items:center;gap:8px;background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:10px}
    .bar h2{font-size:.95rem;margin:0 10px 0 0;color:var(--sub)}
    .bar .spacer{flex:1 1 auto}

    .stage{position:relative;background:#05080c;border:1px solid var(--border);border-radius:12px;overflow:hidden;min-height:320px}
    .layer{position:absolute;inset:0}
    #video{width:100%;height:100%;object-fit:contain;background:#000}
    #imgPreview{width:100%;height:100%;object-fit:contain;display:none}
    #overlay{touch-action:none}

    .card{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:10px;min-height:0}
    .card h3{margin:0 0 .5rem 0;color:var(--sub);font-size:.95rem}

    .results{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    textarea.raw{width:100%;height:240px;background:#0a121a;color:var(--text);border:1px solid var(--border);border-radius:10px;padding:8px;resize:vertical}
    table{width:100%;border-collapse:collapse}
    th,td{border-bottom:1px solid var(--border);padding:6px 8px;text-align:left;vertical-align:top}
    th{color:var(--sub);font-weight:600}
    .status{font-size:.9rem;color:var(--sub)}
    .badge{display:inline-flex;align-items:center;gap:6px;padding:3px 8px;border-radius:999px;border:1px solid var(--border);background:#0f1720}
    .ok{color:var(--good)}.warn{color:var(--warn)}.err{color:var(--bad)}

    button,input[type=file],input[type=text],input[type=number],select{
      appearance:none;border:none;background:var(--panel);color:var(--text);
      padding:8px 10px;border-radius:10px;border:1px solid var(--border);cursor:pointer
    }
    input[type=text],input[type=number],select{width:100%;cursor:text}
    select{cursor:pointer}
    button:hover{border-color:var(--accent)}
    button.primary{background:linear-gradient(180deg, #132435, #0f1c2a);border-color:#223247}
    button.good{border-color:#17392c;background:#0e2b21}
    button.bad{border-color:#3b1e1e;background:#2a1414}

    .fps{position:absolute;bottom:10px;left:10px;background:rgba(0,0,0,.4);padding:4px 8px;border-radius:8px;border:1px solid var(--border);font-size:.8rem}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}

    /* Responsive tweak */
    @media (max-width: 1100px){
      .app{grid-template-columns:1fr}
      .left{order:2}
      .right{order:1}
      .results{grid-template-columns:1fr}
    }
  </style>
</head>
<body>
  <div class="app">
    <!-- LADO IZQUIERDO -->
    <aside class="left">
      <h1>OCR de Documentos</h1>

      <div class="card" style="margin-bottom:12px">
        <h3>ROIs (plantilla)</h3>
        <div class="status" id="roiCount" style="margin-bottom:6px">0 ROIs</div>
        <div class="bar" style="padding:8px">
          <button id="btnAddRoi">Agregar ROI</button>
          <button id="btnDeleteRoi" class="bad">Eliminar ROI</button>
          <button id="btnClearRois" class="bad">Limpiar ROIs</button>
        </div>
        <div class="bar" style="padding:8px;margin-top:8px">
          <button id="btnExport">Exportar JSON</button>
          <input type="file" id="fileImport" accept="application/json" />
        </div>

        <!-- Propiedades ROI -->
        <div class="bar" style="padding:8px;margin-top:8px;display:grid;grid-template-columns:1fr 1fr;gap:8px">
          <input id="roiName" type="text" placeholder="Nombre ROI" />
          <select id="roiType">
            <option value="text">text</option>
            <option value="image">image</option>
            <option value="mrz">mrz</option>
            <option value="pdf417">pdf417</option>
            <option value="barcode">barcode</option>
          </select>
          <input id="roiX" type="number" step="0.001" min="0" max="1" placeholder="x (0..1)" />
          <input id="roiY" type="number" step="0.001" min="0" max="1" placeholder="y (0..1)" />
          <input id="roiW" type="number" step="0.001" min="0.02" max="1" placeholder="w (0..1)" />
          <input id="roiH" type="number" step="0.001" min="0.02" max="1" placeholder="h (0..1)" />
        </div>

        <div class="status" style="margin-top:6px">
          Tip: Click para seleccionar · Arrastra para mover · Arrastra bordes/esquinas para redimensionar · Supr/Backspace borra.
        </div>
      </div>

      <div class="card" style="margin-bottom:12px">
        <h3>Extracción por ROI</h3>
        <div class="bar" style="padding:8px">
          <button id="btnExtractSelected" class="good">Extraer ROI Seleccionado</button>
          <button id="btnExtractAll">Extraer todos los ROIs</button>
        </div>
        <div class="status" style="margin-top:6px">
          Tipos: <span class="mono">text, image, mrz, pdf417, barcode</span>
        </div>
      </div>

      <div class="card">
        <h3>Modelo de detección</h3>
        <div class="status" style="display:grid;gap:6px">
          <div>Motor: <span id="sEngine" class="badge">cargando…</span></div>
          <div>Modelo: <span id="sModel" class="badge">cargando…</span></div>
        </div>
      </div>
    </aside>

    <!-- LADO DERECHO -->
    <main class="right">
      <!-- Cámara arriba -->
      <div class="bar" id="cameraBar">
        <h2>Cámara</h2>
        <button id="btnStart" class="primary">Iniciar</button>
        <button id="btnStop">Detener</button>
        <button id="btnShot" class="good">Capturar Imagen</button>
        <button id="btnShotDoc" class="good">Capturar solo Documento</button>
        <div class="spacer"></div>
        <label class="status" style="display:flex;align-items:center;gap:8px">
          <input type="checkbox" id="chkAuto" /> Auto-detectar
        </label>
        <span id="fps" class="badge mono">FPS: <span id="fpsVal">—</span></span>
      </div>

      <!-- Stage -->
      <section id="stage" class="stage">
        <video id="video" class="layer" autoplay muted playsinline></video>
        <img id="imgPreview" class="layer" alt="Previsualización" />
        <canvas id="overlay" class="layer"></canvas>
        <div class="fps mono" id="fpsOverlay">— fps</div>
      </section>

      <!-- Imagen abajo -->
      <div class="bar" id="imageBar">
        <h2>Imagen</h2>
        <input type="file" id="file" accept="image/*" />
        <button id="btnParseFull">Extraer y Parsear (Imagen Completa)</button>
      </div>

      <!-- Resultados -->
      <section class="results">
        <div class="card">
          <h3>Texto crudo OCR</h3>
          <textarea id="raw" class="raw" placeholder="Aquí aparecerá el texto crudo…"></textarea>
          <div style="margin-top:8px">
            <button id="btnParseRaw" title="Parsear el contenido actual del área de texto sin volver a ejecutar OCR">Parsear Texto Crudo</button>
          </div>
        </div>
        <div class="card">
          <h3>Datos parseados</h3>
          <div id="status" class="status">Esperando extracción…</div>
          <div style="overflow:auto;max-height:260px">
            <table id="tbl"><thead><tr><th>Campo</th><th>Valor</th></tr></thead><tbody></tbody></table>
          </div>
        </div>
      </section>
    </main>
  </div>

  <!-- =============== LÓGICA =============== -->
  <script>
    // ====== Estado global
    const state = {
      stream: null,
      running: false,
      autoDetect: false,
      usingImage: false,
      lastDetections: [],
      selectedRoiId: null,
      rois: [], // {id,name,type,x,y,w,h} coords relativos [0..1]
      workerId: null,
      engine: null,
      activeBitmap: null,
      activeNatural: {w:0,h:0}
    };

    // ====== DOM
    const $video = document.getElementById('video');
    const $imgPreview = document.getElementById('imgPreview');
    const $overlay = document.getElementById('overlay');
    const ctx = $overlay.getContext('2d');
    const $fpsOverlay = document.getElementById('fpsOverlay');
    const $fpsVal = document.getElementById('fpsVal');
    const $sEngine = document.getElementById('sEngine');
    const $sModel = document.getElementById('sModel');
    const $raw = document.getElementById('raw');
    const $tbl = document.getElementById('tbl').querySelector('tbody');
    const $status = document.getElementById('status');
    const $roiCount = document.getElementById('roiCount');
    const $roiName = document.getElementById('roiName');
    const $roiType = document.getElementById('roiType');
    const $roiX = document.getElementById('roiX');
    const $roiY = document.getElementById('roiY');
    const $roiW = document.getElementById('roiW');
    const $roiH = document.getElementById('roiH');

    // ====== InferenceJS
    async function initEngine(){
      try{
        $sEngine.textContent = 'listo';
        state.engine = new inferencejs.InferenceEngine();
        $sModel.textContent = 'cargando…';
        state.workerId = await state.engine.startWorker(
          'react-project-wdxr6',
          '1',
          'rf_hHUmNcZwoGhdPO3kyAlI6YY4R4m2'
        );
        $sModel.textContent = 'OK';
      }catch(err){
        console.error(err);
        $sModel.textContent = 'error';
      }
    }

    // ====== Overlay
    function resizeOverlay(){
      const host = state.usingImage ? $imgPreview : $video;
      const w = host.clientWidth || host.getBoundingClientRect().width;
      const h = host.clientHeight || host.getBoundingClientRect().height;
      $overlay.width  = Math.round(w * devicePixelRatio);
      $overlay.height = Math.round(h * devicePixelRatio);
      $overlay.style.width  = w + 'px';
      $overlay.style.height = h + 'px';
      drawOverlay();
    }
    addEventListener('resize', ()=>setTimeout(resizeOverlay,50));

    // ====== Cámara
    async function startCamera(){
      try{
        state.stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'},audio:false});
        $video.srcObject = state.stream;
        await $video.play();
        state.running = true;
        state.usingImage = false;
        $imgPreview.style.display = 'none';
        $video.style.display = 'block';
        requestAnimationFrame(loop);
        setTimeout(resizeOverlay, 150);
      }catch(err){ console.error(err); }
    }
    function stopCamera(){
      state.running = false;
      if(state.stream){
        state.stream.getTracks().forEach(t=>t.stop());
        state.stream = null;
      }
    }

    // ====== Cargar imagen
    document.getElementById('file').addEventListener('change', async (e)=>{
      const f = e.target.files?.[0]; if(!f) return;
      const url = URL.createObjectURL(f);
      $imgPreview.src = url;
      $imgPreview.onload = async ()=>{
        URL.revokeObjectURL(url);
        state.usingImage = true;
        $video.style.display='none';
        $imgPreview.style.display='block';
        const bmp = await imageBitmapFromImg($imgPreview);
        state.activeBitmap = bmp; state.activeNatural={w:bmp.width,h:bmp.height};
        resizeOverlay();
      };
    });

    // ====== Bucle detección
    let frames=0, lastFpsTs=0, lastPromptTs=0;
    async function loop(ts){
      if(!state.running) return;
      if(!$video.videoWidth){ requestAnimationFrame(loop); return; }

      frames++; if(ts-lastFpsTs>1000){
        const fps = Math.round(frames*1000/(ts-lastFpsTs));
        $fpsOverlay.textContent = fps+' fps';
        $fpsVal.textContent = fps;
        frames=0; lastFpsTs=ts;
      }

      const w=$video.videoWidth,h=$video.videoHeight;
      const bmp = await createImageBitmap($video, {resizeWidth:w,resizeHeight:h});
      state.activeBitmap = bmp; state.activeNatural={w,h};
      drawOverlay();

      if(state.autoDetect && state.workerId){
        try{
          const cvimg = new inferencejs.CVImage($video);
          const preds = await state.engine.infer(state.workerId, cvimg);
          state.lastDetections = preds||[];
          drawOverlay();

          const best = _.maxBy(state.lastDetections, p=>p.confidence||0);
          if(best && (best.confidence||0) >= 0.65 && ts-lastPromptTs>1200){
            lastPromptTs = ts;
            confirmCapture(best);
          }
        }catch(e){ console.warn('infer error', e); }
      }
      requestAnimationFrame(loop);
    }

    async function confirmCapture(det){
      const ok = confirm('Se detectó un documento con alta confianza. ¿Deseas capturar esa región?');
      if(!ok) return;
      const crop = cropFromDetection(det);
      await showPreviewBitmap(crop);
      runOCROnActive('Captura de documento');
    }

    function cropFromDetection(det){
      const {w:W,h:H} = state.activeNatural;
      const {x,y,width,height} = det.bbox; // centro + dimensiones
      const x0 = Math.max(0, Math.round(x - width/2));
      const y0 = Math.max(0, Math.round(y - height/2));
      const ww = Math.min(W - x0, Math.round(width));
      const hh = Math.min(H - y0, Math.round(height));
      const off = new OffscreenCanvas(ww, hh);
      off.getContext('2d').drawImage(state.activeBitmap, x0, y0, ww, hh, 0, 0, ww, hh);
      return off.transferToImageBitmap();
    }

    async function showPreviewBitmap(bmp){
      const c = new OffscreenCanvas(bmp.width, bmp.height);
      const g = c.getContext('2d');
      g.drawImage(bmp,0,0);
      const blob = await c.convertToBlob({type:'image/png', quality:0.92});
      const url = URL.createObjectURL(blob);
      $imgPreview.src = url;
      $imgPreview.onload = ()=>{ URL.revokeObjectURL(url); };
      state.usingImage = true;
      $video.style.display='none';
      $imgPreview.style.display='block';
      state.activeBitmap = bmp; state.activeNatural={w:bmp.width,h:bmp.height};
      setTimeout(resizeOverlay, 100);
    }

    // ====== Dibujo overlay
    function drawOverlay(){
      const view = $overlay.getBoundingClientRect();
      const viewW = view.width, viewH = view.height;

      ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
      ctx.clearRect(0,0,$overlay.width,$overlay.height);

      // Letterboxing (object-fit: contain)
      const natW = state.activeNatural.w || 1, natH = state.activeNatural.h || 1;
      const scale = Math.min(viewW/natW, viewH/natH);
      const contentW = natW * scale, contentH = natH * scale;
      const offX = (viewW - contentW)/2, offY = (viewH - contentH)/2;

      // Detecciones
      for(const p of state.lastDetections){
        const {x,y,width,height} = p.bbox;
        const sx = offX + (x - width/2) * scale;
        const sy = offY + (y - height/2) * scale;
        const sw = width * scale, sh = height * scale;

        ctx.strokeStyle = '#5ac8fa';
        ctx.lineWidth = 2;
        ctx.strokeRect(sx, sy, sw, sh);
        ctx.fillStyle = 'rgba(90,200,250,.12)';
        ctx.fillRect(sx, sy, sw, sh);
        ctx.fillStyle = '#cfe9fb';
        ctx.font = '12px ui-monospace';
        const tag = `${p.class||'doc'} ${(p.confidence||0).toFixed(2)}`;
        ctx.fillText(tag, sx+6, sy+14);
      }

      // ROIs
      roisDraw({width:viewW, height:viewH});
    }

    // ====== ROI manager
    function roisDraw(view){
      for(const roi of state.rois){
        const x = roi.x*view.width, y=roi.y*view.height, w=roi.w*view.width, h=roi.h*view.height;
        const selected = (roi.id===state.selectedRoiId);

        ctx.strokeStyle = selected?'#34d399':'#9fb3c8';
        ctx.lineWidth = selected?2:1.5;
        ctx.strokeRect(x,y,w,h);
        if(selected){
          ctx.fillStyle='rgba(52,211,153,.07)';
          ctx.fillRect(x,y,w,h);
        }

        ctx.fillStyle='#cfe9fb';
        ctx.font='12px ui-monospace';
        ctx.fillText(`${roi.name||('ROI '+roi.id)} · ${roi.type||'text'}`, x+6, y+14);

        if(selected){
          const H=10;
          const pts=[
            [x,y], [x+w/2-H/2,y], [x+w-H,y],
            [x+w-H,y+h/2-H/2], [x+w-H,y+h-H],
            [x+w/2-H/2,y+h-H], [x,y+h-H],
            [x,y+h/2-H/2]
          ];
          ctx.fillStyle='#5ac8fa';
          pts.forEach(([px,py])=>{
            ctx.fillRect(px,py,H,H);
            ctx.strokeStyle='#00121c'; ctx.lineWidth=1;
            ctx.strokeRect(px,py,H,H);
          });
        }
      }
    }

    function updateRoiCount(){ $roiCount.textContent = state.rois.length + ' ROIs'; }

    function syncRoiPropsPanel(){
      const a = state.rois.find(r=>r.id===state.selectedRoiId);
      const disabled = !a;
      [$roiName,$roiType,$roiX,$roiY,$roiW,$roiH].forEach(inp=>{ inp.disabled = disabled; });
      if(a){
        $roiName.value = a.name || '';
        $roiType.value = a.type || 'text';
        $roiX.value = a.x.toFixed(3);
        $roiY.value = a.y.toFixed(3);
        $roiW.value = a.w.toFixed(3);
        $roiH.value = a.h.toFixed(3);
      }else{
        $roiName.value=''; $roiType.value='text'; $roiX.value=''; $roiY.value=''; $roiW.value=''; $roiH.value='';
      }
    }

    function addRoiFromRect(px,py,pw,ph){
      const r = $overlay.getBoundingClientRect();
      const rx = px / r.width,  ry = py / r.height;
      const rw = pw / r.width,  rh = ph / r.height;

      const roi = {
        id: _.uniqueId('roi_'),
        name: 'ROI',
        type: 'text',
        x: Math.max(0, rx),
        y: Math.max(0, ry),
        w: Math.max(0.02, Math.min(1, rw)),
        h: Math.max(0.02, Math.min(1, rh))
      };
      state.rois.push(roi);
      state.selectedRoiId = roi.id;
      updateRoiCount(); drawOverlay(); syncRoiPropsPanel();
    }

    function pickRoi(px,py){
      const r = $overlay.getBoundingClientRect();
      const rx = px / r.width, ry = py / r.height;
      for(let i=state.rois.length-1;i>=0;i--){
        const a=state.rois[i];
        if(rx>=a.x && ry>=a.y && rx<=a.x+a.w && ry<=a.y+a.h){ return a; }
      }
      return null;
    }

    function removeSelected(){
      if(!state.selectedRoiId) return;
      _.remove(state.rois, r=>r.id===state.selectedRoiId);
      state.selectedRoiId = null; updateRoiCount(); drawOverlay(); syncRoiPropsPanel();
    }

    // Interacción ROIs
    const drag = {mode:null, roi:null, origin:{x:0,y:0}, handle:null};

    function overlayPointFromEvent(e){
      const r = $overlay.getBoundingClientRect();
      const pt = (e.touches? e.touches[0]: e);
      const x = Math.min(Math.max(pt.clientX - r.left, 0), r.width);
      const y = Math.min(Math.max(pt.clientY - r.top,  0), r.height);
      return {x,y};
    }

    function handleAt(roi,px,py){
      const r = $overlay.getBoundingClientRect();
      const x = roi.x*r.width, y=roi.y*r.height, w=roi.w*r.width, h=roi.h*r.height;
      const H=12;
      const within=(ax,ay)=> px>=ax && py>=ay && px<=ax+H && py<=ay+H;
      if(within(x,y)) return 'nw';
      if(within(x+w/2-H/2,y)) return 'n';
      if(within(x+w-H,y)) return 'ne';
      if(within(x+w-H,y+h/2-H/2)) return 'e';
      if(within(x+w-H,y+h-H)) return 'se';
      if(within(x+w/2-H/2,y+h-H)) return 's';
      if(within(x,y+h-H)) return 'sw';
      if(within(x,y+h/2-H/2)) return 'w';
      return null;
    }

    function onDown(e){
      const pt = overlayPointFromEvent(e);
      const pick = pickRoi(pt.x,pt.y);
      if(pick){
        state.selectedRoiId = pick.id; drawOverlay(); syncRoiPropsPanel();
        const h = handleAt(pick, pt.x, pt.y);
        drag.mode = h? 'resize':'move'; drag.roi = _.cloneDeep(pick); drag.origin={x:pt.x,y:pt.y}; drag.handle=h; e.preventDefault();
      }else{
        drag.mode='new'; drag.origin={x:pt.x,y:pt.y}; drag.roi=null; e.preventDefault();
      }
    }
    function onMove(e){
      if(!drag.mode) return;
      const pt = overlayPointFromEvent(e); const dx=pt.x-drag.origin.x, dy=pt.y-drag.origin.y;
      const r = $overlay.getBoundingClientRect();

      if(drag.mode==='new'){
        drawOverlay();
        ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
        ctx.strokeStyle='#34d399'; ctx.lineWidth=2; ctx.setLineDash([6,6]);
        ctx.strokeRect(drag.origin.x, drag.origin.y, dx, dy);
        ctx.setLineDash([]);
      }
      if(drag.mode==='move' && drag.roi){
        const a = _.find(state.rois, {id: state.selectedRoiId}); if(!a) return;
        const rx = dx / r.width, ry = dy / r.height;
        a.x = _.clamp(drag.roi.x + rx, 0, 1 - a.w);
        a.y = _.clamp(drag.roi.y + ry, 0, 1 - a.h);
        drawOverlay(); syncRoiPropsPanel();
      }
      if(drag.mode==='resize' && drag.roi){
        const a = _.find(state.rois, {id: state.selectedRoiId}); if(!a) return;
        const rx = dx / r.width, ry = dy / r.height;
        let {x,y,w,h} = drag.roi;
        const hnd = drag.handle;
        if(hnd==='n'||hnd==='ne'||hnd==='nw'){ h = _.clamp(h - ry, 0.02, 1); y = _.clamp(y + ry, 0, y+h); }
        if(hnd==='s'||hnd==='se'||hnd==='sw'){ h = _.clamp(h + ry, 0.02, 1); }
        if(hnd==='w'||hnd==='nw'||hnd==='sw'){ w = _.clamp(w - rx, 0.02, 1); x = _.clamp(x + rx, 0, x+w); }
        if(hnd==='e'||hnd==='ne'||hnd==='se'){ w = _.clamp(w + rx, 0.02, 1); }
        a.x=x; a.y=y; a.w=w; a.h=h; drawOverlay(); syncRoiPropsPanel();
      }
      e.preventDefault();
    }
    function onUp(e){
      if(drag.mode==='new'){
        const pt = overlayPointFromEvent(e); const x=Math.min(drag.origin.x, pt.x); const y=Math.min(drag.origin.y, pt.y);
        const w=Math.abs(pt.x-drag.origin.x); const h=Math.abs(pt.y-drag.origin.y);
        if(w>10 && h>10) addRoiFromRect(x,y,w,h);
      }
      drag.mode=null; drag.roi=null; drag.handle=null;
    }

    $overlay.addEventListener('mousedown', onDown); $overlay.addEventListener('mousemove', onMove); $overlay.addEventListener('mouseup', onUp);
    $overlay.addEventListener('touchstart', onDown, {passive:false}); $overlay.addEventListener('touchmove', onMove, {passive:false}); $overlay.addEventListener('touchend', onUp);
    addEventListener('keydown', (e)=>{ if(e.key==='Delete' || e.key==='Backspace') removeSelected(); });

    // Inputs/props ROI
    [$roiName,$roiType,$roiX,$roiY,$roiW,$roiH].forEach(inp=>{
      inp.addEventListener('input', ()=>{
        const a = state.rois.find(r=>r.id===state.selectedRoiId);
        if(!a) return;
        if(inp===$roiName){ a.name = $roiName.value; }
        else if(inp===$roiType){ a.type = $roiType.value; }
        else{
          const v = _.clamp(parseFloat(inp.value||'0')||0, 0, 1);
          if(inp===$roiX) a.x = v;
          if(inp===$roiY) a.y = v;
          if(inp===$roiW) a.w = Math.max(0.02, v);
          if(inp===$roiH) a.h = Math.max(0.02, v);
        }
        drawOverlay();
      });
    });
    syncRoiPropsPanel();

    // ====== Exportar / Importar
    document.getElementById('btnExport').addEventListener('click',()=>{
      const data = { schema:'roi-template:v1', size: state.activeNatural, rois: state.rois };
      const blob = new Blob([JSON.stringify(data,null,2)], {type:'application/json'});
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'plantilla-roi.json'; a.click();
      setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
    });
    document.getElementById('fileImport').addEventListener('change', async (e)=>{
      const f=e.target.files?.[0]; if(!f) return; const txt = await f.text();
      try{
        const j = JSON.parse(txt);
        if(j && Array.isArray(j.rois)) { state.rois = j.rois.map(r=>({type:'text',...r})); updateRoiCount(); drawOverlay(); syncRoiPropsPanel(); }
      }catch(err){ alert('JSON inválido'); }
    });

    // ====== Botones
    document.getElementById('btnStart').addEventListener('click', startCamera);
    document.getElementById('btnStop').addEventListener('click', stopCamera);
    document.getElementById('btnShot').addEventListener('click', async ()=>{
      if(!$video.videoWidth && !$imgPreview.complete) return;
      const bmp = state.usingImage ? await imageBitmapFromImg($imgPreview) : await createImageBitmap($video);
      await showPreviewBitmap(bmp);
    });
    document.getElementById('btnShotDoc').addEventListener('click', async ()=>{
      if(!state.workerId) return alert('Modelo no listo');
      const host = state.usingImage ? $imgPreview : $video;
      const cvimg = new inferencejs.CVImage(host);
      const preds = await state.engine.infer(state.workerId, cvimg);
      if(!preds?.length) return alert('No se detectó documento');
      const best = _.maxBy(preds, p=>p.confidence||0);
      const bmp = state.usingImage ? await imageBitmapFromImg($imgPreview) : await createImageBitmap($video);
      state.activeBitmap = bmp; state.activeNatural={w:bmp.width,h:bmp.height};
      const crop = cropFromDetection(best);
      await showPreviewBitmap(crop);
      runOCROnActive('Captura de documento');
    });
    document.getElementById('chkAuto').addEventListener('change',(e)=>{ state.autoDetect = !!e.target.checked; });

    // === Extracción por ROI ===
    document.getElementById('btnExtractSelected').addEventListener('click', async ()=>{
      const a = state.rois.find(r=>r.id===state.selectedRoiId);
      if(!a) return alert('Selecciona un ROI');
      await extractAndReportROI(a);
    });
    document.getElementById('btnExtractAll').addEventListener('click', async ()=>{
      if(!state.rois.length) return alert('No hay ROIs');
      for(const r of state.rois){ await extractAndReportROI(r); }
      setStatus('Extracción de todos los ROIs finalizada.');
    });

    // ====== OCR + Parseo (imagen completa)
    document.getElementById('btnParseFull').addEventListener('click', ()=>{
      if(!state.usingImage){ alert('Primero sube una imagen o captura una'); return; }
      runOCROnActive('Imagen completa');
    });

    async function imageBitmapFromImg(img){
      const {naturalWidth:w, naturalHeight:h} = img; return await createImageBitmap(img, {resizeWidth:w, resizeHeight:h});
    }

    async function runOCROnActive(contextLabel){
      if(!state.activeBitmap){ alert('No hay imagen activa'); return; }
      setStatus(`Procesando OCR (${contextLabel})…`);
      const c = new OffscreenCanvas(state.activeBitmap.width, state.activeBitmap.height);
      const g = c.getContext('2d'); g.drawImage(state.activeBitmap,0,0);
      const blob = await c.convertToBlob({type:'image/png', quality:0.92});
      const imgUrl = URL.createObjectURL(blob);
      try{
        const worker = await Tesseract.createWorker('spa+eng');
        const { data:{ text } } = await worker.recognize(imgUrl);
        await worker.terminate();
        $raw.value = text.trim();
        parseToTable(text.trim());
        setStatus('OCR completado.');
      }catch(err){ console.error(err); setStatus('Error en OCR', true); }
      finally{ URL.revokeObjectURL(imgUrl); }
    }

    function setStatus(msg,isErr){ $status.innerHTML = `<span class="badge ${isErr?'err':'ok'}">${msg}</span>`; }

    // ====== ROI → píxeles naturales
    function mapRoiToNatural(roi){
      const view = $overlay.getBoundingClientRect();
      const viewW = view.width, viewH = view.height;
      const natW = state.activeNatural.w, natH = state.activeNatural.h;
      if(!natW || !natH) return {x:0,y:0,w:0,h:0};
      const scale = Math.min(viewW/natW, viewH/natH);
      const contentW = natW * scale, contentH = natH * scale;
      const offX = (viewW - contentW)/2, offY = (viewH - contentH)/2;
      const ox = roi.x*viewW, oy = roi.y*viewH, ow = roi.w*viewW, oh = roi.h*viewH;
      const nx = Math.round((ox - offX)/scale);
      const ny = Math.round((oy - offY)/scale);
      const nw = Math.round(ow/scale);
      const nh = Math.round(oh/scale);
      const x = Math.max(0, Math.min(natW, nx));
      const y = Math.max(0, Math.min(natH, ny));
      const w = Math.max(1, Math.min(natW - x, nw));
      const h = Math.max(1, Math.min(natH - y, nh));
      return {x,y,w,h};
    }

    function roiToCanvas(roi){
      const {x,y,w,h} = mapRoiToNatural(roi);
      const off = new OffscreenCanvas(w,h);
      const g = off.getContext('2d');
      g.drawImage(state.activeBitmap, x,y,w,h, 0,0,w,h);
      return off;
    }

    async function canvasToBlobUrl(cnv, type='image/png', quality=0.92){
      const blob = await cnv.convertToBlob({type, quality});
      return URL.createObjectURL(blob);
    }

    function appendRows(rows){
      const html = rows.map(([k,v])=>`<tr><td class="mono">${escapeHtml(k)}</td><td>${escapeHtml(v)}</td></tr>`).join('');
      $tbl.insertAdjacentHTML('beforeend', html);
    }

    // ====== —— MRZ: Normalización & Parseo (tu bloque) —— ======
    function normalizeRawMRZ(t){
      return t
        .replace(/[^\dA-Z<\n]/g,'')
        .replace(/[ \t]+/g,'')
        .toUpperCase()
        .trim();
    }
    function splitNames(s){
      const parts = s.split('<<');
      const surname = (parts[0]||'').replace(/</g,' ').trim();
      const given = (parts[1]||'').replace(/</g,' ').trim();
      return {surname, given};
    }
    function parseTD3(lines){
      const L1 = (lines[0]||'').padEnd(44,'<').slice(0,44);
      const L2 = (lines[1]||'').padEnd(44,'<').slice(0,44);
      const docType = L1.slice(0,2).replace(/</g,'');
      const issuer = L1.slice(2,5).replace(/</g,'');
      const namePart = L1.slice(5);
      const {surname, given} = splitNames(namePart);
      const passportNumber = L2.slice(0,9).replace(/</g,'');
      const nationality = L2.slice(10,13).replace(/</g,'');
      const birth = L2.slice(13,19);
      const sex = L2.slice(20,21).replace(/</g,''); // corregido
      const expiry = L2.slice(21,27);
      const personal = L2.slice(28,42).replace(/</g,'');
      return {
        Formato:'TD3 (Pasaporte)',
        'Tipo de documento':docType,
        'País emisor':issuer,
        'Apellidos':surname,
        'Nombres':given,
        'Número de documento':passportNumber,
        'Nacionalidad':nationality,
        'Fecha de nacimiento (YYMMDD)':birth,
        'Sexo':sex,
        'Fecha de expiración (YYMMDD)':expiry,
        'Número personal':personal
      };
    }
    function parseTD1(lines){
      const L1 = (lines[0]||'').padEnd(30,'<').slice(0,30);
      const L2 = (lines[1]||'').padEnd(30,'<').slice(0,30);
      const L3 = (lines[2]||'').padEnd(30,'<').slice(0,30);
      const docType = L1.slice(0,2).replace(/</g,'');
      const country = L1.slice(2,5).replace(/</g,'');
      const number = L1.slice(5,14).replace(/</g,'');
      const birth = L2.slice(0,6);
      const sex = L2.slice(7,8);
      const expiry = L2.slice(8,14);
      const nationality = L2.slice(15,18).replace(/</g,'');
      const optional = L3.slice(0,30).replace(/</g,' ').trim();
      const {surname, given} = splitNames(L3);
      return {
        Formato:'TD1 (ID 3 líneas)',
        'Tipo de documento':docType,
        'País emisor':country,
        'Número de documento':number,
        'Fecha de nacimiento (YYMMDD)':birth,
        'Sexo':sex,
        'Fecha de expiración (YYMMDD)':expiry,
        'Nacionalidad':nationality,
        'Apellidos':surname,
        'Nombres':given,
        'Dato opcional':optional
      };
    }
    function parseTD2(lines){
      const L1 = (lines[0]||'').padEnd(36,'<').slice(0,36);
      const L2 = (lines[1]||'').padEnd(36,'<').slice(0,36);
      const docType = L1.slice(0,2).replace(/</g,'');
      const country = L1.slice(2,5).replace(/</g,'');
      const namePart = L1.slice(5);
      const {surname, given} = splitNames(namePart);
      const number = L2.slice(0,9).replace(/</g,'');
      const nationality = L2.slice(10,13).replace(/</g,'');
      const birth = L2.slice(13,19);
      const sex = L2.slice(20,21);
      const expiry = L2.slice(21,27);
      const optional = L2.slice(28,35).replace(/</g,' ').trim();
      return {
        Formato:'TD2 (ID 2 líneas)',
        'Tipo de documento':docType,
        'País emisor':country,
        'Apellidos':surname,
        'Nombres':given,
        'Número de documento':number,
        'Nacionalidad':nationality,
        'Fecha de nacimiento (YYMMDD)':birth,
        'Sexo':sex,
        'Fecha de expiración (YYMMDD)':expiry,
        'Dato opcional':optional
      };
    }
    function guessAndParseMRZ(raw){
      const text = normalizeRawMRZ(raw);
      const lines = text.split(/\n+/).map(s=>s.trim()).filter(Boolean);
      if(lines.length>=2 && lines.every(l=>l.length>=36)){
        const L = lines.map(l=>l.replace(/\s+/g,''));
        if(L[0].length>=44 || L[1].length>=44) return parseTD3([L[0].slice(0,44), L[1].slice(0,44)]);
        return parseTD2([L[0].slice(0,36), L[1].slice(0,36)]);
      }else if(lines.length>=3){
        const L = lines.slice(0,3).map(l=>l.replace(/\s+/g,''));
        return parseTD1([L[0].slice(0,30), L[1].slice(0,30), L[2].slice(0,30)]);
      }else{
        throw new Error('No se reconoce el formato MRZ.');
      }
    }

    // ====== Fechas MRZ → ISO + edad y vencimiento ======
    function yyMMddToISO(yyMMdd){
      if(!/^\d{6}$/.test(yyMMdd)) return null;
      const yy = parseInt(yyMMdd.slice(0,2),10);
      const mm = parseInt(yyMMdd.slice(2,4),10);
      const dd = parseInt(yyMMdd.slice(4,6),10);
      // Heurística común MRZ: >=50 => 1900s, <50 => 2000s
      const year = (yy >= 50 ? 1900 : 2000) + yy;
      if(mm<1||mm>12||dd<1||dd>31) return null;
      const m = String(mm).padStart(2,'0');
      const d = String(dd).padStart(2,'0');
      return `${year}-${m}-${d}`;
    }
    function isoToDate(iso){
      const d = new Date(iso+'T00:00:00');
      return isNaN(d.getTime()) ? null : d;
    }
    function yearsBetween(birthISO){
      const d = isoToDate(birthISO); if(!d) return null;
      const now = new Date();
      let age = now.getFullYear() - d.getFullYear();
      const m = now.getMonth() - d.getMonth();
      if(m < 0 || (m === 0 && now.getDate() < d.getDate())) age--;
      return age;
    }
    function daysUntilISO(iso){
      const d = isoToDate(iso); if(!d) return null;
      const now = new Date();
      const msPerDay = 24*60*60*1000;
      return Math.ceil((d - new Date(now.getFullYear(), now.getMonth(), now.getDate())) / msPerDay);
    }
    function augmentMRZ(parsed){
      // Clona para no mutar el original
      const out = {...parsed};
      // Claves posibles según TD1/TD2/TD3:
      const kBirth = 'Fecha de nacimiento (YYMMDD)';
      const kExp   = 'Fecha de expiración (YYMMDD)';

      if(parsed[kBirth]){
        const iso = yyMMddToISO(parsed[kBirth]);
        if(iso){
          out['Fecha de nacimiento'] = iso;
          const age = yearsBetween(iso);
          if(age!=null) out['Edad (años)'] = String(age);
        }
      }
      if(parsed[kExp]){
        const iso = yyMMddToISO(parsed[kExp]);
        if(iso){
          out['Fecha de expiración'] = iso;
          const left = daysUntilISO(iso);
          if(left!=null){
            out['Días hasta expiración'] = String(left);
            out['¿Vencido?'] = left < 0 ? 'Sí' : 'No';
          }
        }
      }
      return out;
    }

    // ====== Área "Texto crudo OCR" → MRZ con augment
    document.getElementById('btnParseRaw').addEventListener('click', ()=>{
      const txt = ($raw.value||'').trim();
      if(!txt){ setStatus('No hay texto para parsear.', true); return; }
      parseToTable(txt);
      setStatus('Texto crudo parseado.');
    });

    function parseToTable(raw){
      $tbl.innerHTML = '';
      // Intento MRZ
      try{
        const parsed = guessAndParseMRZ(raw);
        const enriched = augmentMRZ(parsed);
        const rows = Object.entries(enriched);
        $tbl.innerHTML = rows.map(([k,v])=>`<tr><td class="mono">${escapeHtml(k)}</td><td>${escapeHtml(v)}</td></tr>`).join('');
        return;
      }catch(_) { /* si no es MRZ, continua */ }

      // Heurística genérica "Campo: Valor"
      const rows = [];
      const lines = raw.split(/\r?\n+/).map(s=>s.trim()).filter(Boolean);
      for(const ln of lines){
        const m = ln.match(/^([^:]{2,48})\s*:\s*(.+)$/);
        if(m) rows.push([m[1].trim(), m[2].trim()]);
      }
      if(!rows.length){ lines.slice(0,50).forEach((v,i)=>rows.push([`Línea ${i+1}`, v])); }
      $tbl.innerHTML = rows.map(([k,v])=>`<tr><td class="mono">${escapeHtml(k)}</td><td>${escapeHtml(v)}</td></tr>`).join('');
    }

    // ====== Extracción por ROI (usa guessAndParseMRZ + augment)
    async function extractAndReportROI(roi){
      if(!state.activeBitmap){ alert('No hay imagen activa'); return; }
      const cnv = roiToCanvas(roi);
      const dataUrl = await canvasToBlobUrl(cnv);
      const label = `ROI:${roi.name||roi.id} [${roi.type||'text'}]`;
      try{
        switch((roi.type||'text').toLowerCase()){
          case 'image':{
            const a = document.createElement('a');
            a.href = dataUrl; a.download = `${(roi.name||roi.id)}.png`; a.click();
            appendRows([[label, 'imagen exportada (.png)']]);
            setStatus(`Imagen ROI "${roi.name||roi.id}" exportada.`);
            break;
          }
          case 'text':{
            const text = await ocrCanvas(cnv, 'spa+eng');
            appendRows([[label, text || '(vacío)']]);
            setStatus(`Texto extraído de "${roi.name||roi.id}".`);
            break;
          }
          case 'mrz':{
            const text = await ocrCanvas(cnv, 'eng');
            try{
              const parsed = guessAndParseMRZ(text||'');
              const enriched = augmentMRZ(parsed);
              const rows = Object.entries(enriched).map(([k,v])=>[`${label} · ${k}`, String(v)]);
              appendRows(rows);
              setStatus(`MRZ parseado en "${roi.name||roi.id}".`);
            }catch(e){
              appendRows([[label, 'MRZ no reconocido'], [`${label} · raw`, text||'(vacío)']]);
              setStatus(`MRZ no reconocido en "${roi.name||roi.id}".`, true);
            }
            break;
          }
          case 'pdf417':{
            const res = await decodeBarcodeWithZXing(dataUrl, ['PDF_417']);
            if(res){ appendRows([[label, res.text]]); setStatus(`PDF417 decodificado en "${roi.name||roi.id}".`); }
            else { appendRows([[label, 'PDF417 no encontrado']]); setStatus(`PDF417 no encontrado en "${roi.name||roi.id}".`, true); }
            break;
          }
          case 'barcode':{
            const res = await decodeBarcodeWithZXing(dataUrl, 'ALL');
            if(res){ appendRows([[`${label} · ${res.format}`, res.text]]); setStatus(`Código de barras leído en "${roi.name||roi.id}".`); }
            else { appendRows([[label, 'Sin lectura']]); setStatus(`No se pudo leer código en "${roi.name||roi.id}".`, true); }
            break;
          }
          default:{
            appendRows([[label, 'Tipo no soportado']]);
            setStatus(`Tipo no soportado: ${roi.type}`, true);
          }
        }
      }finally{
        URL.revokeObjectURL(dataUrl);
      }
    }

    async function ocrCanvas(cnv, langs='spa+eng'){
      const url = await canvasToBlobUrl(cnv);
      try{
        const worker = await Tesseract.createWorker(langs);
        const { data:{ text } } = await worker.recognize(url);
        await worker.terminate();
        return (text||'').trim();
      }catch(e){ console.error(e); return ''; }
      finally{ URL.revokeObjectURL(url); }
    }

    async function decodeBarcodeWithZXing(dataUrl, formats='ALL'){
      const img = await dataUrlToImage(dataUrl);
      try{
        if(formats==='ALL'){
          const reader = new ZXing.BrowserMultiFormatReader();
          const res = await reader.decodeFromImage(img).catch(()=>null);
          return res ? {text:res.getText(), format:String(res.getBarcodeFormat())} : null;
        }else if(Array.isArray(formats) && formats.includes('PDF_417')){
          const pdfReader = new ZXing.BrowserPDF417Reader();
          const res = await pdfReader.decodeOnce(img).catch(()=>null);
          return res ? {text:res.getText(), format:'PDF_417'} : null;
        }
        return null;
      }catch(e){
        console.warn('ZXing decode error', e);
        return null;
      }
    }

    function dataUrlToImage(url){
      return new Promise((resolve,reject)=>{
        const img = new Image();
        img.onload = ()=>resolve(img);
        img.onerror = reject;
        img.src = url;
      });
    }

    function escapeHtml(s){ return String(s).replace(/[&<>"']/g, m=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"})[m]); }

    // ====== Inicio
    (async function init(){
      await initEngine();
      await startCamera();
      resizeOverlay();
      syncRoiPropsPanel();
      updateRoiCount();
    })();
  </script>
</body>
</html>
