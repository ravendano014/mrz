<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>OCR y Detector de Códigos de Barras con ROI</title>
<style>
  :root{
    color-scheme: dark;
    --bg:#0b0f14; --panel:#121821; --muted:#708090; --border:#243144; --accent:#3ba0ff; --good:#24c07a; --bad:#ff5964;
  }
  *{box-sizing:border-box}
  body{margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial; background:var(--bg); color:#e6edf3}
  header{padding:16px 20px; border-bottom:1px solid var(--border); background:linear-gradient(180deg,#0d121a,#0b0f14)}
  h1{font-size:18px; margin:0 0 4px}
  p.subtitle{margin:0; color:var(--muted); font-size:13px}
  .container{max-width:1100px; margin:18px auto; padding:0 16px; display:grid; gap:16px}
  .grid{display:grid; grid-template-columns:1.1fr 1fr; gap:16px}
  .card{background:var(--panel); border:1px solid var(--border); border-radius:14px; padding:14px}
  .title{font-size:14px; color:#b9c4d0; margin-bottom:10px; letter-spacing:.2px}
  .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
  button, label.buttonlike{
    background:#172131; border:1px solid var(--border); color:#e6edf3;
    padding:10px 12px; border-radius:10px; cursor:pointer; font-weight:600; font-size:14px
  }
  button:hover, label.buttonlike:hover{border-color:#31405a}
  button.primary{background:var(--accent); color:#001224; border-color:#2c7ed6}
  button.good{background:var(--good); color:#00160c; border-color:#1fa466}
  button.bad{background:var(--bad); color:#240005; border-color:#d34a53}
  input[type="file"]{display:none}
  select, input[type="text"]{
    background:#0f1622; color:#e6edf3; border:1px solid var(--border); border-radius:10px; padding:9px 10px; font-weight:600
  }
  .media{display:grid; gap:8px}
  .viewport{
    display:inline-block; position:relative; width:100%; max-height:360px; aspect-ratio:4/3;
    background:#0a0a0a; border:1px solid var(--border); border-radius:12px; overflow:hidden;
  }
  video, img.preview, canvas{position:absolute; inset:0; width:100%; height:100%; object-fit:contain}
  .status{font-size:13px; color:var(--muted); margin-top:6px; min-height:18px}
  pre.json{margin:0; padding:12px; background:#0f141c; border:1px dashed var(--border); border-radius:10px; overflow:auto; max-height:260px}
  table{width:100%; border-collapse:collapse; font-size:14px}
  th,td{border-bottom:1px solid var(--border); padding:10px 8px; text-align:left}
  th{color:#b9c4d0; font-weight:600}
  .badge{display:inline-flex; align-items:center; gap:6px; font-size:12px; padding:4px 8px; border-radius:999px; border:1px solid var(--border); background:#0f1622}
  .ok{color:var(--good)} .warn{color:var(--bad)}
  .hint{font-size:12px; color:#708090}
  /* Línea guía opcional */
  @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0.4; } 100% { opacity: 1; } }
  .roi-guide { animation: blink 1s step-end infinite; }
  #roiPreview { max-height: 120px; width: 100%; border-radius: 8px; margin-bottom: 10px; border: 1px solid var(--border); background:#0f141c }
</style>
</head>
<body>
<header>
  <h1>OCR y Detector de Códigos de Barras con ROI</h1>
  <p class="subtitle">Dibuja un recuadro ROI con el mouse o los dedos. Captura & extrae usando ese ROI.</p>
</header>

<div class="container">
  <div class="grid">
    <section class="card">
      <div class="title">Entrada (Cámara o Imagen)</div>

      <div class="media">
        <div class="viewport">
          <video id="video" playsinline muted></video>
          <img id="imgPreview" class="preview" alt="Vista previa" style="display:none" />
          <canvas id="canvasGuide" class="roi-guide"></canvas>
          <canvas id="canvasOverlay"></canvas>
        </div>
      </div>

      <div class="row" style="margin-top:10px">
        <button id="startCam" class="primary">Iniciar cámara</button>
        <button id="stopCam" class="bad" disabled>Detener cámara</button>
        <button id="captureAndExtract" class="good" disabled>Capturar &amp; Extraer</button>

        <label class="buttonlike">
          Subir imagen
          <input id="fileInput" type="file" accept="image/*" />
        </label>
        <button id="extractFromImage">Extraer de imagen</button>
        <button id="autoDetectROI">Auto-ajustar ROI (Barra)</button>
      </div>

      <div class="row" style="margin-top:10px">
        <label class="badge">Idioma OCR:
          <select id="langSelect" style="margin-left:8px">
            <option value="eng" selected>Inglés (eng)</option>
            <option value="spa">Español (spa)</option>
            <option value="ita">Italiano (ita)</option>
            <option value="fra">Francés (fra)</option>
          </select>
        </label>
        <input id="langCustom" type="text" placeholder="Código(s) extra: p. ej., eng+spa" size="24" />
      </div>

      <div class="row" style="margin-top:8px">
        <label><input id="beepChk" type="checkbox"> Sonido al detectar</label>
        <label><input id="detailsChk" type="checkbox" checked> Mostrar detalles (BB/Puntos)</label>
      </div>

      <div class="row" style="margin-top:8px">
        <span class="badge" id="camBadge">Cámara: <strong id="camState">detenida</strong></span>
        <span class="badge">Idioma actual: <strong id="langBadge">eng</strong></span>
        <span class="hint">Formatos compatibles: <span id="formats">—</span></span>
      </div>
      <div class="status" id="status">Listo.</div>
    </section>

    <section class="card">
      <div class="title">Resultados</div>
      <canvas id="roiPreview" style="display:none;"></canvas>
      <div class="row" style="gap:12px; margin-bottom:10px">
        <button id="clear">Limpiar</button>
        <span id="quality" class="badge">Confianza OCR: —</span>
        <span id="barcodesFound" class="badge">Códigos detectados: 0</span>
      </div>
      <pre id="jsonOut" class="json">{}</pre>
      <div style="height:10px"></div>
      <table id="tableOut">
        <thead><tr><th>Campo</th><th>Valor</th></tr></thead>
        <tbody></tbody>
      </table>
    </section>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
<script type="module">
  import { BarcodeDetectorPolyfill } from "https://cdn.jsdelivr.net/npm/@undecaf/barcode-detector-polyfill@latest/dist/main.js";

  // ---------- refs ----------
  const el = {};
  document.querySelectorAll('[id]').forEach(e => el[e.id] = e);

  const video   = el.video;
  const canvasGuide = el.canvasGuide;
  const canvasOverlay = el.canvasOverlay;
  const imgPrev = el.imgPreview;
  const roiPreview = el.roiPreview;
  const status  = el.status;
  const jsonOut = el.jsonOut;
  const table   = el.tableOut.querySelector('tbody');
  const camBadge= el.camState;
  const langBadge = el.langBadge;
  const quality = el.quality;
  const barcodesFound = el.barcodesFound;
  const autoDetectROIButton = el.autoDetectROI; // Referencia al nuevo botón

  const ctxOverlay = canvasOverlay.getContext('2d');
  const ctxGuide = canvasGuide.getContext('2d');
  const ctxRoiPrev = roiPreview.getContext('2d');

  // ---------- state ----------
  let detector = null;
  let supportedFormats = [];
  let stream = null;
  let lastImageEl = null;
  let videoRequestId = null;

  let audioCtx = null;  // audio context fix
  let lastBeepAt = 0;

  // ROI en coordenadas de canvasOverlay (px)
  let roi = null; // {x,y,w,h}
  const HANDLE = 10; // px para agarraderas
  let dragMode = null; // 'move' | 'nw'|'ne'|'sw'|'se'|'n'|'s'|'w'|'e' | 'draw'
  let dragStart = null; // {x,y}
  const MIN_W = 20, MIN_H = 20;

  // ---------- utils ----------
  function setStatus(msg){ status.textContent = msg; }
  function currentLang(){
    const custom = (el.langCustom.value || '').trim();
    const lang = custom || el.langSelect.value || 'eng';
    langBadge.textContent = lang;
    return lang;
  }
  el.langSelect.addEventListener('change', currentLang);
  el.langCustom.addEventListener('input', currentLang);

  // Ajusta tamaños de canvases a tamaño visible
  function syncCanvasSizes(){
    const W = canvasOverlay.clientWidth;
    const H = canvasOverlay.clientHeight;
    canvasOverlay.width = W; canvasOverlay.height = H;
    canvasGuide.width = W;   canvasGuide.height = H;
    drawGuide();
    drawOverlay();
  }

  // Línea guía (opcional)
  function drawGuide() {
    const W = canvasGuide.width, H = canvasGuide.height;
    ctxGuide.clearRect(0, 0, W, H);
    const y = H/2;
    ctxGuide.lineWidth = 3;
    ctxGuide.strokeStyle = '#ff5964';
    ctxGuide.beginPath();
    ctxGuide.moveTo(W*0.1, y);
    ctxGuide.lineTo(W*0.9, y);
    ctxGuide.stroke();
  }

  // Dibuja máscara, rectángulo ROI y agarraderas
  function drawOverlay(){
    const W = canvasOverlay.width, H = canvasOverlay.height;
    ctxOverlay.clearRect(0,0,W,H);

    if (!roi) {
      // Un mensaje sutil
      ctxOverlay.fillStyle = 'rgba(0,0,0,0.25)';
      ctxOverlay.fillRect(0,0,W,H);
      ctxOverlay.fillStyle = '#b9c4d0';
      ctxOverlay.font = '12px system-ui';
      ctxOverlay.fillText('Dibuja un ROI: arrastra con el mouse o los dedos', 12, 20);
      return;
    }

    // Máscara fuera del ROI
    ctxOverlay.fillStyle = 'rgba(0,0,0,0.45)';
    ctxOverlay.fillRect(0,0,W,roi.y); // arriba
    ctxOverlay.fillRect(0,roi.y,roi.x,roi.h); // izquierda
    ctxOverlay.fillRect(roi.x+roi.w,roi.y,W-(roi.x+roi.w),roi.h); // derecha
    ctxOverlay.fillRect(0,roi.y+roi.h,W,H-(roi.y+roi.h)); // abajo

    // Borde ROI
    ctxOverlay.lineWidth = 2;
    ctxOverlay.strokeStyle = '#3ba0ff';
    ctxOverlay.setLineDash([6,4]);
    ctxOverlay.strokeRect(roi.x, roi.y, roi.w, roi.h);
    ctxOverlay.setLineDash([]);

    // Agarraderas
    ctxOverlay.fillStyle = '#3ba0ff';
    const handles = getHandlePoints(roi);
    for (const p of handles) ctxOverlay.fillRect(p.x-HANDLE/2, p.y-HANDLE/2, HANDLE, HANDLE);
  }

  function getHandlePoints(r){
    return [
      {name:'nw', x:r.x, y:r.y},
      {name:'ne', x:r.x+r.w, y:r.y},
      {name:'sw', x:r.x, y:r.y+r.h},
      {name:'se', x:r.x+r.w, y:r.y+r.h},
      {name:'n',  x:r.x+r.w/2, y:r.y},
      {name:'s',  x:r.x+r.w/2, y:r.y+r.h},
      {name:'w',  x:r.x, y:r.y+r.h/2},
      {name:'e',  x:r.x+r.w, y:r.y+r.h/2},
    ];
  }
  function hitTestHandle(x,y){
    if (!roi) return null;
    for(const h of getHandlePoints(roi)){
      if (Math.abs(x-h.x) <= HANDLE && Math.abs(y-h.y) <= HANDLE) return h.name;
    }
    // dentro del ROI para mover
    if (x>=roi.x && x<=roi.x+roi.w && y>=roi.y && y<=roi.y+roi.h) return 'move';
    return null;
  }

  function getPointFromEvent(ev){
    if (ev.touches && ev.touches.length){
      const t = ev.touches[0];
      const rect = canvasOverlay.getBoundingClientRect();
      return { x: t.clientX - rect.left, y: t.clientY - rect.top };
    } else {
      const rect = canvasOverlay.getBoundingClientRect();
      return { x: ev.clientX - rect.left, y: ev.clientY - rect.top };
    }
  }

  function clampROI(r){
    const W = canvasOverlay.width, H = canvasOverlay.height;
    if (r.w < MIN_W) r.w = MIN_W;
    if (r.h < MIN_H) r.h = MIN_H;
    
    // Ajustar límites de X
    if (r.x < 0) r.x = 0;
    if (r.x + r.w > W) r.x = W - r.w;
    
    // Ajustar límites de Y
    if (r.y < 0) r.y = 0;
    if (r.y + r.h > H) r.y = H - r.h;
  }

  function setCursor(mode){
    const map = {
      move:'move', n:'ns-resize', s:'ns-resize', w:'ew-resize', e:'ew-resize',
      nw:'nwse-resize', se:'nwse-resize', ne:'nesw-resize', sw:'nesw-resize', draw:'crosshair'
    };
    canvasOverlay.style.cursor = map[mode] || 'crosshair';
  }

  // ---------- ROI interactions ----------
  function onPointerDown(ev){
    ev.preventDefault();
    const p = getPointFromEvent(ev);
    const hit = roi ? hitTestHandle(p.x,p.y) : null;

    if (!roi || !hit){
      // empezar a dibujar desde cero
      roi = { x:p.x, y:p.y, w:1, h:1 };
      dragMode = 'draw';
    } else {
      dragMode = hit;
      dragStart = { x:p.x, y:p.y, rx:roi.x, ry:roi.y, rw:roi.w, rh:roi.h };
    }
    drawOverlay();
  }
  function onPointerMove(ev){
    const p = getPointFromEvent(ev);
    if (!dragMode){
      setCursor(roi ? (hitTestHandle(p.x,p.y) || 'draw') : 'draw');
      return;
    }

    if (dragMode === 'draw'){
      roi.w = p.x - roi.x;
      roi.h = p.y - roi.y;
      if (roi.w < 0){ roi.x += roi.w; roi.w = -roi.w; }
      if (roi.h < 0){ roi.y += roi.h; roi.h = -roi.h; }
      clampROI(roi);
    } else if (dragMode === 'move'){
      const dx = p.x - dragStart.x, dy = p.y - dragStart.y;
      roi.x = dragStart.rx + dx;
      roi.y = dragStart.ry + dy;
      clampROI(roi);
    } else {
      // resize por lados/esquinas
      const r = { ...dragStart };
      const dx = p.x - dragStart.x, dy = p.y - dragStart.y;
      if (dragMode.includes('e')) r.rw += dx;
      if (dragMode.includes('s')) r.rh += dy;
      if (dragMode.includes('w')) { r.rx += dx; r.rw -= dx; }
      if (dragMode.includes('n')) { r.ry += dy; r.rh -= dy; }
      // aplicar
      roi.x = r.rx; roi.y = r.ry; roi.w = r.rw; roi.h = r.rh;
      if (roi.w < 0){ roi.x += roi.w; roi.w = -roi.w; }
      if (roi.h < 0){ roi.y += roi.h; roi.h = -roi.h; }
      clampROI(roi);
    }
    drawOverlay();
  }
  function onPointerUp(ev){
    dragMode = null;
    drawOverlay();
  }

  // Eventos mouse/touch
  canvasOverlay.addEventListener('mousedown', onPointerDown);
  window.addEventListener('mousemove', onPointerMove);
  window.addEventListener('mouseup', onPointerUp);

  canvasOverlay.addEventListener('touchstart', onPointerDown, {passive:false});
  window.addEventListener('touchmove', onPointerMove, {passive:false});
  window.addEventListener('touchend', onPointerUp);

  // ---------- Auto-detección ROI (NUEVA FUNCIÓN) ----------
  async function autoSelectROI(sourceEl){
    setStatus('Buscando códigos de barras para auto-ajustar el ROI...');

    // 1. Obtener las dimensiones de la fuente real y el viewport
    const sW = sourceEl.naturalWidth || sourceEl.videoWidth || sourceEl.width;
    const sH = sourceEl.naturalHeight || sourceEl.videoHeight || sourceEl.height;
    const vW = canvasOverlay.width;
    const vH = canvasOverlay.height;

    if (!sW || !sH || !vW || !vH) {
      setStatus('Fuente o viewport no válidos para auto-ajuste.');
      return false;
    }

    // 2. Detectar códigos de barras en la imagen completa
    const symbols = await detector.detect(sourceEl);

    if (symbols.length === 0) {
      setStatus('No se detectaron códigos de barras para auto-ajustar el ROI.');
      return false;
    }

    // 3. Usar el primer bounding box detectado
    const bb = symbols[0].boundingBox;
    if (!bb) {
      setStatus('Código detectado sin bounding box, no se puede auto-ajustar.');
      return false;
    }

    // 4. Mapear el bounding box real (source coords) a las coordenadas del viewport (canvasOverlay)
    const scaleX = vW / sW;
    const scaleY = vH / sH;

    // Calcular el ROI en coordenadas del viewport, aplicando un margen (e.g., 20px en el viewport)
    const margin = 20;
    const vx = bb.x * scaleX;
    const vy = bb.y * scaleY;
    const vw = bb.width * scaleX;
    const vh = bb.height * scaleY;

    // Ajustar el ROI con el margen, asegurando que no se salga de los límites del viewport
    const newRoi = {
      x: Math.max(0, vx - margin),
      y: Math.max(0, vy - margin),
      w: vw + margin * 2,
      h: vh + margin * 2
    };

    // Ajustar W y H para que no se excedan los límites del canvas
    newRoi.w = Math.min(newRoi.w, vW - newRoi.x);
    newRoi.h = Math.min(newRoi.h, vH - newRoi.y);
    
    // Aplicar el nuevo ROI y forzar la validación (clampROI)
    roi = newRoi;
    clampROI(roi);

    // 5. Actualizar la interfaz
    drawOverlay();
    setStatus(`ROI auto-ajustado alrededor de un código de barras detectado (${symbols[0].format}).`);
    return true;
  }
  
  // ---------- Barcode ----------
  async function createBarcodeDetector() {
    supportedFormats = await BarcodeDetectorPolyfill.getSupportedFormats();
    el.formats.textContent = supportedFormats.join(', ');
    detector = new BarcodeDetectorPolyfill({ formats: supportedFormats });
  }

  async function detectBarcodes(source) {
    const sW = source.naturalWidth || source.videoWidth || source.width || canvasOverlay.clientWidth;
    const sH = source.naturalHeight || source.videoHeight || source.height || canvasOverlay.clientHeight;

    // No pintamos overlay aquí (podría ser ROI), el loop en vivo sí.
    const symbols = await detector.detect(source);

    if (el.beepChk.checked && symbols.length) beep();

    // Limpia detalles si no se piden
    return symbols.map(s => {
      const obj = { ...s };
      if (!el.detailsChk.checked) {
        delete obj.boundingBox;
        delete obj.cornerPoints;
      }
      return obj;
    });
  }

  // Bucle de detección en vivo (usando la fuente de video para dibujar BB en pantalla completa)
  function detectVideoLoop(on) {
    if (on) {
      drawOverlay(); // mantener overlay
      detector.detect(video).then(symbols=>{
        // dibuja bounding boxes del stream completo (guía visual)
        const sW = canvasOverlay.width, sH = canvasOverlay.height;
        // no limpiar ROI/máscara ya hecha; solo extra layer
        ctxOverlay.save();
        ctxOverlay.lineWidth = 3;
        ctxOverlay.strokeStyle = '#24c07a';
        ctxOverlay.setLineDash([8,5]);
        for (const s of symbols) {
          if (s.cornerPoints && s.cornerPoints.length){
            ctxOverlay.beginPath();
            const pts = s.cornerPoints;
            ctxOverlay.moveTo(pts[0].x / video.videoWidth * sW, pts[0].y / video.videoHeight * sH);
            for (let i=1;i<pts.length;i++){
              ctxOverlay.lineTo(pts[i].x / video.videoWidth * sW, pts[i].y / video.videoHeight * sH);
            }
            ctxOverlay.closePath();
            ctxOverlay.stroke();
          }
        }
        ctxOverlay.restore();
        videoRequestId = requestAnimationFrame(()=>detectVideoLoop(true));
      }).catch(()=>{
        videoRequestId = requestAnimationFrame(()=>detectVideoLoop(true));
      });
    } else {
      if (videoRequestId) cancelAnimationFrame(videoRequestId);
      videoRequestId = null;
    }
  }

  // ---------- Beep ----------
  function beep() {
    const now = performance.now();
    if (now - lastBeepAt < 600) return;
    lastBeepAt = now;

    if (!audioCtx) {
      try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch {}
    }
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'sine';
    osc.frequency.value = 880;
    gain.gain.value = 0.08;
    osc.connect(gain).connect(audioCtx.destination);
    osc.start();
    setTimeout(() => osc.stop(), 150);
  }

  // ---------- Preproceso & OCR ----------
  function preprocessToCanvas(srcEl){
    const canvas = document.createElement('canvas');
    const w = srcEl.naturalWidth || srcEl.videoWidth || srcEl.width;
    const h = srcEl.naturalHeight || srcEl.videoHeight || srcEl.height;
    if(!w || !h){ throw new Error('Imagen no válida.'); }
    canvas.width = w; canvas.height = h;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(srcEl, 0, 0, w, h);
    const imgData = ctx.getImageData(0,0,w,h);
    const d = imgData.data;
    const contrast = 1.35, threshold = 155;
    for(let i=0;i<d.length;i+=4){
      const r=d[i], g=d[i+1], b=d[i+2];
      let gray = 0.2126*r + 0.7152*g + 0.0722*b;
      gray = (gray-128)*contrast + 128;
      const v = gray > threshold ? 255 : 0;
      d[i]=d[i+1]=d[i+2]=v;
    }
    ctx.putImageData(imgData,0,0);
    return canvas;
  }

  async function runOCR(srcEl){
    const lang = currentLang();
    setStatus(`Preparando OCR (${lang})…`);
    const pre = preprocessToCanvas(srcEl);

    const worker = await Tesseract.createWorker(lang, 1, {
      logger: m => {
        if(m.status) setStatus(`OCR (${lang}): ${m.status}${m.progress ? ' ' + Math.round(m.progress*100)+'%' : ''}`);
      }
    });

    try{
      const { data } = await worker.recognize(pre);
      const texto = (data.text || '').trim().replace(/\s+/g,' ');
      const digits = (texto.match(/\d+/g) || []).join('') || '';
      const digitsArr = digits ? digits.split('').map(Number) : [];
      const conf = Array.isArray(data.words) && data.words.length
        ? data.words.reduce((s,w)=>s+(w.confidence||0),0)/data.words.length
        : (data.confidence ?? 0);

      return {
        idioma_ocr: lang,
        texto_bruto: texto,
        digitos: digits,
        arreglo_digitos: digitsArr,
        confianza_media: Number((conf||0).toFixed(2))
      };

    }catch(err){
      console.error('Error en OCR:', err);
      setStatus('Error en OCR: ' + err.message);
      return { error_ocr: err.message, idioma_ocr: lang, confianza_media: 0 };
    }finally{
      await worker.terminate();
    }
  }

  // ---------- ROI -> fuente recortada ----------
  function applyROIFromRect(source){
    // Dimensiones reales de la fuente
    const sW = source.naturalWidth || source.videoWidth || source.width;
    const sH = source.naturalHeight || source.videoHeight || source.height;
    if (!sW || !sH) throw new Error('Fuente no válida.');

    // Dimensiones visibles de overlay
    const vW = canvasOverlay.width;
    const vH = canvasOverlay.height;

    // Mapear ROI (coordenadas canvasOverlay) a coordenadas de la fuente
    const scaleX = sW / vW;
    const scaleY = sH / vH;

    const cropX = Math.max(0, Math.round(roi.x * scaleX));
    const cropY = Math.max(0, Math.round(roi.y * scaleY));
    const cropW = Math.min(sW - cropX, Math.round(roi.w * scaleX));
    const cropH = Math.min(sH - cropY, Math.round(roi.h * scaleY));

    const roiCanvas = document.createElement('canvas');
    roiCanvas.width = cropW;
    roiCanvas.height = cropH;
    const roiCtx = roiCanvas.getContext('2d');
    roiCtx.drawImage(source, cropX, cropY, cropW, cropH, 0, 0, cropW, cropH);

    // Mostrar preview
    roiPreview.style.display = 'block';
    roiPreview.width = cropW;
    roiPreview.height = cropH;
    ctxRoiPrev.clearRect(0,0,roiPreview.width,roiPreview.height);
    ctxRoiPrev.drawImage(roiCanvas, 0, 0);

    return roiCanvas;
  }

  // ---------- Extracción combinada ----------
  async function runExtraction(roiSource){
    const barcodes = await detectBarcodes(roiSource);
    barcodesFound.textContent = `Códigos detectados: ${barcodes.length}`;
    barcodesFound.style.borderColor = barcodes.length > 0 ? 'var(--good)' : 'var(--border)';

    const ocrResult = await runOCR(roiSource);

    const finalPayload = {
      codigos_barras: barcodes,
      ocr: ocrResult
    };

    jsonOut.textContent = JSON.stringify(finalPayload, null, 2);
    table.innerHTML = '';

    addRow('--- CÓDIGOS DE BARRAS (Desde ROI) ---', '');
    if (barcodes.length === 0) {
      addRow('Resultado', 'No se detectaron códigos de barras.');
    } else {
      barcodes.forEach((b, i) => {
        const value = el.detailsChk.checked ? JSON.stringify(b) : `${b.format}: ${b.rawValue}`;
        addRow(`Código #${i+1}`, value);
      });
    }

    addRow('--- OCR (Reconocimiento de Texto desde ROI) ---', '');
    addRow('Idioma OCR', ocrResult.idioma_ocr);
    addRow('Texto bruto', ocrResult.texto_bruto || '—');
    addRow('Dígitos (solo números)', ocrResult.digitos || '—');
    addRow('Arreglo de dígitos', (ocrResult.arreglo_digitos?.length ? '['+ocrResult.arreglo_digitos.join(', ')+']' : '—'));
    if (typeof ocrResult.confianza_media === 'number') {
      addRow('Confianza media', ocrResult.confianza_media + '%');
      quality.innerHTML = `Confianza OCR: <strong>${ocrResult.confianza_media.toFixed(2)}%</strong>`;
      quality.style.borderColor = ocrResult.confianza_media >= 70 ? 'var(--good)' : 'var(--bad)';
      quality.style.color = ocrResult.confianza_media >= 70 ? 'var(--good)' : 'var(--bad)';
    } else {
      addRow('Confianza media', '—');
      quality.innerHTML = 'Confianza OCR: —';
      quality.style.removeProperty('border-color'); quality.style.removeProperty('color');
    }

    setStatus('Extracción combinada finalizada (aplicado ROI).');
  }

  function addRow(k,v){
    const tr=document.createElement('tr');
    const td1=document.createElement('td'); td1.textContent=k;
    const td2=document.createElement('td'); td2.textContent=v;
    if(k.startsWith('---')){ td1.colSpan = 2; td1.style.fontWeight = 'bold'; td1.style.color = 'var(--accent)'; td2.style.display = 'none'; }
    tr.appendChild(td1); tr.appendChild(td2); table.appendChild(tr);
  }

  // ---------- Cámara / Imagen ----------
  el.startCam.addEventListener('click', async ()=>{
    if (videoRequestId) return;
    try{
      stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}, audio:false});
      video.srcObject = stream;
      await video.play();
      el.stopCam.disabled = false;
      el.captureAndExtract.disabled = true;
      camBadge.textContent='iniciando…';
      video.onplaying = ()=>{
        el.captureAndExtract.disabled=false; camBadge.textContent='activa';
        imgPrev.style.display='none'; video.style.display='block';
        syncCanvasSizes();
        drawOverlay();
        setStatus('Cámara iniciada. Dibuja/ajusta el ROI y usa “Capturar & Extraer”.');
        detectVideoLoop(true);
      };
      lastImageEl = null;
    }catch(err){
      setStatus('No se pudo iniciar la cámara: ' + err.message);
    }
  });

  el.stopCam.addEventListener('click', ()=>{
    detectVideoLoop(false);
    if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
    video.pause(); video.srcObject=null;
    el.stopCam.disabled=true;
    el.captureAndExtract.disabled=true;
    camBadge.textContent='detenida';
    setStatus('Cámara detenida.');
    video.style.display='none';
    ctxOverlay.clearRect(0,0,canvasOverlay.width,canvasOverlay.height);
  });

  el.fileInput.addEventListener('change', ()=>{
    el.stopCam.click(); // asegurar detener
    const f = el.fileInput.files && el.fileInput.files[0];
    if(!f) return;
    const url = URL.createObjectURL(f);
    imgPrev.src = url; imgPrev.style.display='block';
    video.style.display='none';
    setStatus('Imagen cargada. Dibuja/ajusta el ROI y presiona “Extraer de imagen”.');
    lastImageEl = imgPrev;
    roi = null; // nuevo ROI
    syncCanvasSizes();
  });

  el.captureAndExtract.addEventListener('click', async ()=>{
    if(!stream || video.readyState<2){ setStatus('La cámara no está lista.'); return; }
    
    // Si no hay ROI, intenta el auto-ajuste (NUEVA LÓGICA)
    if(!roi){ 
        const success = await autoSelectROI(video);
        if(!success){
            setStatus('Primero dibuja el ROI sobre el video o no se pudo auto-ajustar.'); 
            return;
        }
    }
    
    try {
      // Usa el ROI recién dibujado o el auto-ajustado
      const roiSource = applyROIFromRect(video);
      await runExtraction(roiSource);
    } catch (e) {
      setStatus('Error al aplicar ROI: ' + e.message);
    }
  });

  el.extractFromImage.addEventListener('click', async ()=>{
    if(!lastImageEl){ setStatus('No hay imagen. Carga una imagen o usa la cámara.'); return; }
    
    // Si no hay ROI, intenta el auto-ajuste (NUEVA LÓGICA)
    if(!roi){
        const success = await autoSelectROI(lastImageEl);
        if(!success){
            setStatus('Primero dibuja el ROI sobre la imagen o no se pudo auto-ajustar.'); 
            return;
        }
    }

    try {
      // Usa el ROI recién dibujado o el auto-ajustado
      const roiSource = applyROIFromRect(lastImageEl);
      await runExtraction(roiSource);
    } catch (e) {
      setStatus('Error al aplicar ROI: ' + e.message);
    }
  });
  
  // Event listener para el nuevo botón de Auto-ajuste (NUEVO BOTÓN)
  el.autoDetectROI.addEventListener('click', async ()=>{
    let source = null;
    if(stream && video.readyState >= 2){
        source = video; // Cámara activa
    } else if (lastImageEl) {
        source = lastImageEl; // Imagen cargada
    } else {
        setStatus('No hay fuente activa (cámara o imagen) para auto-ajustar.');
        return;
    }
    
    // Ejecutar el auto-ajuste
    await autoSelectROI(source);
  });

  el.clear.addEventListener('click', ()=>{
    jsonOut.textContent='{}';
    table.innerHTML='';
    quality.innerHTML='Confianza OCR: —';
    quality.style.removeProperty('border-color'); quality.style.removeProperty('color');
    barcodesFound.textContent = 'Códigos detectados: 0';
    barcodesFound.style.removeProperty('border-color');
    setStatus('Limpio.');
    ctxOverlay.clearRect(0, 0, canvasOverlay.width, canvasOverlay.height);
    roiPreview.style.display = 'none';
    ctxRoiPrev.clearRect(0, 0, roiPreview.width, roiPreview.height);
    roi = null;
    drawOverlay();
  });

  // Habilitar contexto de audio en primer gesto (si está marcado beep)
  ['click','change'].forEach(evt => {
    document.addEventListener(evt, () => {
      if (!audioCtx && el.beepChk.checked) {
        try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch {}
      }
    }, { once:true, capture:true });
  });

  // ---------- Init ----------
  await createBarcodeDetector();
  const ro = new ResizeObserver(syncCanvasSizes);
  ro.observe(document.querySelector('.viewport'));

  // ocultar al inicio
  video.style.display='none';
  imgPrev.style.display='none';
  syncCanvasSizes(); // establece tamaños y dibuja overlay inicial
  setStatus('Listo. Inicia cámara o sube una imagen, luego dibuja el ROI.');

</script>
</body>
</html>
