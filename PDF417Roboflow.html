<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>PDF417 ‚Äî C√°mara / Imagen, ROI preciso + Capturar ROI (c√°mara) + Auto-captura</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- ====== Librer√≠as por CDN ====== -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/inferencejs@1.1.3"></script>
  <!-- ZXing UMD (compatible con PDF417) -->
  <script src="https://cdn.jsdelivr.net/npm/@zxing/library@0.20.0/umd/index.min.js"></script>

  <style>
    :root{
      --bg:#0b0f12; --fg:#e6edf3; --muted:#93a1ad; --accent:#39d353; --danger:#ff6b6b;
      --panel:#0f1419; --card:#11161c; --line:#1b2631; --btn:#1a2633; --btn2:#14202b; --yellow:#ffd866;
    }
    *{ box-sizing:border-box }
    html,body{height:100%;margin:0}
    body{
      background:linear-gradient(180deg,var(--bg),#050709 60%); color:var(--fg);
      font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";
      overflow:hidden;
    }
    #stage{ position:fixed; inset:0; background:#000; z-index: 1; }
    #video{
      position:absolute; inset:0; width:100%; height:100%; object-fit:contain; background:#000; display:block !important; z-index:1;
    }
    #overlay{ position:absolute; inset:0; width:100%; height:100%; object-fit:contain; pointer-events:none; z-index:2; }

    #panel{
      position:fixed; top:0; right:0; height:100%; width:min(520px, 44vw);
      background:linear-gradient(180deg,var(--panel),#0b1117); border-left:1px solid var(--line);
      padding:14px 14px 120px; overflow:auto; box-shadow:-8px 0 24px rgba(0,0,0,.35); z-index:3;
    }
    #panel h1{ font-size:16px; margin:0 0 8px; letter-spacing:.3px }
    .sub{ color:var(--muted); font-size:12px; margin:0 0 12px }
    .row{ display:flex; gap:8px; flex-wrap:wrap; margin:8px 0; align-items:center }
    .seg{ padding:10px; border:1px solid var(--line); border-radius:12px; background:#0e141a }
    button{
      background:var(--btn); color:var(--fg); border:1px solid var(--line); border-radius:10px; padding:8px 10px;
      cursor:pointer; font-weight:600;
    }
    button:hover{ background:var(--btn2) }
    button.primary{ border-color:#254a2f; background:#13281a }
    button.success{ border-color:#224e37; background:#10261d }
    button.warn{ border-color:#4a3b17; background:#241d0c }
    button.danger{ border-color:#4f1f1f; background:#281012; color:#ffdede }
    button:disabled{ opacity:.5; cursor:not-allowed }
    .ghost{ background:transparent }
    label.small{ font-size:12px; color:var(--muted) }

    textarea, pre, input[type="text"], input[type="number"]{
      width:100%; background:var(--card); color:var(--fg); border:1px solid var(--line);
      border-radius:10px; padding:8px; font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
    }
    input[type="number"]{ width:86px; }
    textarea{ min-height:110px; resize:vertical }
    .grid{ display:grid; gap:8px; }
    .split2{ grid-template-columns:1fr 1fr }
    .split3{ grid-template-columns:auto auto auto; align-items:center }
    table{
      width:100%; border-collapse:collapse; background:var(--card); border:1px solid var(--line);
      border-radius:10px; overflow:hidden; display:block; max-height:260px; overflow:auto;
    }
    th,td{ padding:8px; border-bottom:1px solid var(--line); text-align:left; font-size:13px }
    th{ position:sticky; top:0; background:#0f1820; z-index:1 }

    .status{
      position:fixed; left:12px; right:calc(min(520px, 44vw) + 12px); bottom:12px;
      display:flex; gap:8px; align-items:center; flex-wrap:wrap;
      padding:10px 12px; border-radius:12px; background:#0d1318cc; backdrop-filter: blur(4px);
      border:1px solid var(--line); z-index: 4;
    }
    .pill{ padding:4px 8px; border-radius:999px; font-weight:700; letter-spacing:.3px; border:1px solid var(--line); background:#0f161ccc }
    .ok{ color:#c9ffd9; border-color:#1f4e2c; background:#0e2316 }
    .bad{ color:#ffd3d3; border-color:#5a1f1f; background:#2a1010 }
    .info{ color:#d2e8ff; border-color:#1d3f61; background:#0f1f2d }
    .fps{ margin-left:auto }

    .spacer{ height:6px }
    .hidden{ display:none !important }
    .preview{ width:100%; aspect-ratio:4/3; border:1px dashed #2a3b4d; border-radius:10px; background:#0b0f12; display:grid; place-items:center; overflow:hidden; }
    .preview canvas, .preview img{ width:100%; height:100%; object-fit:contain }
    .badge{ padding:2px 6px; border-radius:6px; border:1px solid var(--line); background:#0e141a; color:#ffd866; font-weight:700 }
    .tag{ font-size:11px; color:#9fb3c8 }

    .tabs{ display:flex; gap:6px; flex-wrap:wrap; margin-bottom:6px }
    .tab{ padding:6px 10px; border-radius:999px; border:1px solid var(--line); background:#0f1419; cursor:pointer; font-weight:600; }
    .tab.active{ background:#122222; border-color:#214a33 }

    .help-message {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: rgba(15, 20, 25, 0.9); border: 1px solid var(--line); border-radius: 12px;
      padding: 20px; text-align: center; max-width: 320px; z-index: 5; backdrop-filter: blur(4px);
    }

    /* Canvas imagen con ROI (t√°ctil/mouse) */
    #imgCanvasPreview{
      width:100%; height:auto; border-radius:10px; background:#0b0f12; border:1px solid var(--line);
      cursor:crosshair; touch-action:none; -webkit-user-select:none; user-select:none; outline:none;
    }
    #roiPreview{ border:1px dashed #2b3b60; border-radius:10px; background:#0f1726 }
    .hintbox{ font-size:12px; color:#9fb3c8 }
  </style>
</head>
<body>

  <!-- Escenario c√°mara -->
  <div id="stage">
    <div class="help-message" id="helpMessage">
      <h3>Inicia la c√°mara</h3>
      <p>Haz clic en "‚ñ∂ Iniciar c√°mara" para comenzar</p>
    </div>
    <video id="video" autoplay muted playsinline></video>
    <canvas id="overlay"></canvas>
  </div>

  <!-- Panel -->
  <aside id="panel">
    <h1>PDF417 ‚Äî c√°mara e imagen (ROI preciso + Auto-captura)</h1>
    <p class="sub">Roboflow (InferenceJS), **Capturar ROI (c√°mara)** manual/autom√°tica desde bbox, ROI preciso en imagen, y parseo JSON.</p>

    <!-- C√°mara -->
    <div class="row">
      <button id="btnStart" class="primary">‚ñ∂ Iniciar c√°mara</button>
      <button id="btnStop" class="danger">‚ñ† Detener c√°mara</button>
      <button id="btnFlip">‚Ü∫ Cambiar c√°mara</button>
      <button id="btnCaptureCamROI" class="success" disabled>‚ßâ Capturar ROI (c√°mara)</button>
      <span class="badge">Detecci√≥n: InferenceJS</span>
    </div>

    <!-- Auto-captura -->
    <div class="row seg">
      <div class="grid split3" style="gap:10px">
        <label class="small"><input type="checkbox" id="chkAuto" /> Auto-captura</label>
        <label class="small">Umbral conf. ‚â• <input type="number" id="numThresh" min="0" max="1" step="0.01" value="0.60" /></label>
        <label class="small">Pausa (s) <input type="number" id="numCooldown" min="0" max="30" step="0.5" value="2.5" /></label>
      </div>
      <p class="sub" style="margin-top:6px">Si la confianza de la detecci√≥n supera el umbral, se captura el ROI autom√°ticamente y se pausa el disparo por el tiempo indicado.</p>
    </div>

    <!-- Imagen -->
    <div class="row seg">
      <div class="tabs">
        <div class="tab active" data-pane="pane-img">Imagen</div>
        <div class="tab" data-pane="pane-raw">Texto crudo</div>
      </div>

      <!-- Pane: Imagen con ROI preciso -->
      <div id="pane-img" style="width:100%">
        <div class="row">
          <input id="fileImage" type="file" accept="image/*" class="hidden" />
          <button id="btnPick" class="warn">üñºÔ∏è Cargar imagen</button>
          <button id="btnDetectImg" class="">üîé Detectar en imagen</button>
          <button id="btnProcessFull" class="">‚á£ Extraer (imagen completa)</button>
          <button id="btnProcessROI" class="success">‚ßâ Extraer (ROI)</button>
          <span class="tag" id="tag-detector">Decoder: auto (BarcodeDetector/ZXing)</span>
        </div>

        <canvas id="imgCanvasPreview" class="hidden" tabindex="0" aria-label="Canvas de imagen con ROI"></canvas>

        <div class="hintbox">
          Arrastra dentro del rect√°ngulo para mover; usa los 8 puntos (esquinas/lados) para redimensionar.
          M√≥vil: un dedo mueve; dos dedos (pinch) escalan. Con el canvas enfocado: flechas mueven (Shift = 5 px),
          +/- cambia tama√±o (Shift = x3).
        </div>

        <div class="grid split2" style="margin-top:8px">
          <div>
            <label>Vista previa ROI (imagen o c√°mara)</label>
            <div class="preview"><canvas id="roiPreview" width="200" height="150"></canvas></div>
          </div>
          <div>
            <label>JSON parseado</label>
            <textarea id="txtJson" placeholder='{"campo":"valor", ‚Ä¶}'></textarea>
          </div>
        </div>
      </div>

      <!-- Pane: Texto crudo pegado -->
      <div id="pane-raw" class="hidden" style="width:100%">
        <div class="grid">
          <label>Texto crudo (raw PDF417)</label>
          <textarea id="txtRaw" placeholder="Pega aqu√≠ la cadena le√≠da (o se llenar√° al extraer)‚Ä¶"></textarea>
        </div>
        <div class="row" style="margin-top:6px">
          <button id="btnParse">{} Parsear JSON</button>
          <button id="btnClearRaw" class="ghost">Limpiar</button>
        </div>
      </div>
    </div>

    <div class="spacer"></div>
    <div class="grid">
      <label>Tabla</label>
      <table id="tbl"><thead><tr><th>Campo</th><th>Valor</th></tr></thead><tbody></tbody></table>
    </div>

    <div class="spacer"></div>
    <p class="sub">Consejo: acerca el c√≥digo al centro del encuadre y evita reflejos.</p>
  </aside>

  <div class="status" id="status">
    <span class="pill info" id="sCam">C√°mara: detenida</span>
    <span class="pill info" id="sModel">Modelo: cargando‚Ä¶</span>
    <span class="pill info" id="sDec">Decoder: inicializando‚Ä¶</span>
    <span class="pill ok hidden" id="sHit">Detectado</span>
    <span class="pill bad hidden" id="sMiss">Sin detecci√≥n</span>
    <span class="pill info fps" id="sFPS">FPS: ‚Äî</span>
  </div>

  <script>
  (function(){
    const { InferenceEngine, CVImage } = inferencejs;
    const ZX = window.ZXing; // UMD
    const $ = window.jQuery;

    // ====== Elementos ======
    const video = document.getElementById('video');
    const overlay = document.getElementById('overlay');
    const octx = overlay.getContext('2d');
    const helpMessage = document.getElementById('helpMessage');

    const sCam = $('#sCam'), sModel = $('#sModel'), sDec = $('#sDec'), sHit = $('#sHit'), sMiss = $('#sMiss'), sFPS = $('#sFPS');
    const tagDetector = $('#tag-detector');

    // Imagen / ROI
    const imgCanvasPreview = document.getElementById('imgCanvasPreview');
    const imgCtx = imgCanvasPreview.getContext('2d');
    const roiPreview = document.getElementById('roiPreview');
    const roiCtx = roiPreview.getContext('2d');

    // ====== Estado ======
    let facingMode = 'environment';
    let stream = null;
    let running = false;
    let sourceMode = 'video'; // 'video' | 'image'

    const engine = new InferenceEngine();
    let workerId = null;
    let rafId = 0;
    let lastBBox = null; // bbox de c√°mara (centro + size)
    let lastTS = performance.now(), fpsSMA = [];

    // Auto-captura
    let isAuto = false;
    let captureCooldown = false;

    // Imagen cargada a resoluci√≥n nativa (fuera de vista)
    const imgCanvasFull = document.createElement('canvas');
    const ifctx = imgCanvasFull.getContext('2d');

    // ROI (imagen) relativo [0..1]
    let imgLoaded = false;
    let roi = { x:0.15, y:0.25, w:0.70, h:0.50 };
    let drawSize = { w:0, h:0 }; // tama√±o dibujado en preview

    // Interacci√≥n ROI precisa (imagen)
    const HANDLE = 12; // px
    const MIN_SIZE_PX = 16;
    let action = null; // 'move' | 'n'|'s'|'e'|'w'|'ne'|'nw'|'se'|'sw'
    let start = {x:0,y:0}; // px en preview
    let startRoi = null;

    // Pinch zoom (imagen)
    let activeTouches = new Map();
    let pinchStartDist = 0;
    let pinchStartRoi = null;

    // Decodificador
    let hasBarcodeDetector = ('BarcodeDetector' in window);
    let nativePdf417Supported = false;
    let pdfReader = null; // ZXing BrowserPDF417Reader

    // ====== Utilidades ======
    function setCanvasToVideoSize() {
      const vw = video.videoWidth || 1280;
      const vh = video.videoHeight || 720;
      overlay.width = vw; overlay.height = vh;
    }

    function updateFPS() {
      const now = performance.now();
      const delta = now - lastTS;
      lastTS = now;
      const fps = 1000 / delta;
      fpsSMA.push(fps);
      if (fpsSMA.length > 20) fpsSMA.shift();
      const avg = fpsSMA.reduce((a,b)=>a+b,0)/fpsSMA.length || 0;
      sFPS.text(`FPS: ${avg.toFixed(0)}`);
    }

    function paintBox(ctx, bbox, label='pdf417', conf=1){
      ctx.lineWidth = 4; ctx.font = '16px ui-monospace';
      const {x,y,width,height} = bbox;
      ctx.strokeStyle = '#39d353';
      ctx.strokeRect(x - width/2, y - height/2, width, height);
      const tag = `${label} ${(conf*100|0)}%`;
      const tw = ctx.measureText(tag).width + 10;
      ctx.fillStyle = '#13281a';
      ctx.fillRect(x - width/2, y - height/2 - 22, tw, 20);
      ctx.fillStyle = '#c9ffd9';
      ctx.fillText(tag, x - width/2 + 5, y - height/2 - 7);
    }

    function setHit(ok){
      if (ok){ sHit.removeClass('hidden'); sMiss.addClass('hidden'); $('#btnCaptureCamROI').prop('disabled', false); }
      else { sMiss.removeClass('hidden'); sHit.addClass('hidden'); $('#btnCaptureCamROI').prop('disabled', true); }
    }

    function escapeHtml(str){
      return String(str).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('"','&quot;').replaceAll("'","&#39;");
    }

    function renderTable(obj){
      const $tb = $('#tbl tbody'); $tb.empty();
      if (!obj || typeof obj!=='object') return;
      Object.entries(obj).forEach(([k,v])=>{
        let val = (typeof v==='object') ? JSON.stringify(v) : String(v);
        if (val.length > 300) val = val.slice(0,300)+'‚Ä¶';
        $tb.append(`<tr><td>${escapeHtml(k)}</td><td>${escapeHtml(val)}</td></tr>`);
      });
    }

    function setStatus(msg, type){
      const el = document.getElementById('status');
      el.textContent = msg;
      el.className = 'status';
      if(type==='ok') el.classList.add('ok');
      else if(type==='bad') el.classList.add('bad');
      else el.classList.add('info');
    }

    // ====== C√°mara ======
    async function startCamera(){
      stopCamera();
      try{
        const constraints = { video: { facingMode, width: { ideal: 1280 }, height: { ideal: 720 } }, audio: false };
        stream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = stream;
        await new Promise((resolve) => { video.onloadedmetadata = resolve; });
        await video.play();
        setCanvasToVideoSize();
        sCam.removeClass('bad info').addClass('ok').text(`C√°mara: activa (${facingMode})`);
        sourceMode = 'video';
        helpMessage.classList.add('hidden');
        running = true;
        loopDetect();
      }catch(err){
        sCam.removeClass('ok info').addClass('bad').text('C√°mara: error - ' + err.message);
        helpMessage.innerHTML = '<h3>Error de c√°mara</h3><p>' + err.message + '</p>';
        helpMessage.classList.remove('hidden');
      }
    }
    function stopCamera(){
      running = false;
      if (rafId) cancelAnimationFrame(rafId);
      if (stream){ stream.getTracks().forEach(t=>t.stop()); stream = null; }
      sCam.removeClass('ok info').addClass('bad').text('C√°mara: detenida');
      helpMessage.innerHTML = '<h3>Inicia la c√°mara</h3><p>Haz clic en "‚ñ∂ Iniciar c√°mara" para comenzar</p>';
      helpMessage.classList.remove('hidden');
      octx.clearRect(0,0,overlay.width,overlay.height);
      setHit(false);
    }

    // ====== Modelo Roboflow (InferenceJS) ======
    async function loadModel(){
      try{
        sModel.removeClass('ok bad').addClass('info').text('Modelo: cargando‚Ä¶');
        workerId = await engine.startWorker(
          "pdf417-kl4vz-hl0le",
          "1",
          "rf_hHUmNcZwoGhdPO3kyAlI6YY4R4m2"
        );
        sModel.removeClass('bad info').addClass('ok').text('Modelo: listo');
      }catch(e){
        sModel.removeClass('ok info').addClass('bad').text('Modelo: error');
        console.error(e);
      }
    }

    // ====== Decoder (BarcodeDetector nativo ‚Üí fallback ZXing) ======
    async function initDecoder(){
      let using = 'ZXing (fallback)';
      pdfReader = new ZX.BrowserPDF417Reader();
      if (hasBarcodeDetector) {
        try{
          const formats = await BarcodeDetector.getSupportedFormats?.();
          nativePdf417Supported = Array.isArray(formats) && formats.includes('pdf417');
        }catch{}
        if (nativePdf417Supported) using = 'BarcodeDetector (nativo)';
      }
      sDec.removeClass('bad info').addClass('ok').text('Decoder: listo');
      $('#tag-detector').text(`Decoder: ${using}`);
    }

    async function decodeFromCanvas(canvas){
      // 1) Nativo
      if (nativePdf417Supported) {
        try{
          const bd = new BarcodeDetector({ formats:['pdf417'] });
          const bitmap = await createImageBitmap(canvas);
          const codes = await bd.detect(bitmap);
          if (codes && codes.length) {
            const hit = codes.find(c=>c.rawValue) || codes[0];
            return hit.rawValue || '';
          }
        }catch(e){ /* fallback */ }
      }
      // 2) ZXing
      try{
        const url = canvas.toDataURL('image/png');
        const img = new Image();
        await new Promise(res=>{ img.onload=res; img.src=url; });
        if (typeof pdfReader.decodeFromImageElement === 'function') {
          const res = await pdfReader.decodeFromImageElement(img);
          return res?.getText?.() || res?.text || '';
        }
        if (typeof pdfReader.decodeOnceFromImageElement === 'function') {
          const res = await pdfReader.decodeOnceFromImageElement(img);
          return res?.getText?.() || res?.text || '';
        }
      }catch(e){}
      return '';
    }

    // ====== Bucle de detecci√≥n (c√°mara) ======
    async function loopDetect(){
      if (!running || !workerId || !video.videoWidth) { rafId = requestAnimationFrame(loopDetect); return; }
      const image = new CVImage(video);
      try{
        const preds = await engine.infer(workerId, image);
        octx.clearRect(0,0,overlay.width,overlay.height);
        if (preds && preds.length){
          // Elige el PDF417 con mayor confianza
          const best = preds.reduce((a,b)=>{
            const ap = (a.class||'').toLowerCase().includes('pdf') ? a : null;
            const bp = (b.class||'').toLowerCase().includes('pdf') ? b : null;
            if(!ap) return bp || a;
            if(!bp) return ap;
            return (bp.confidence > ap.confidence) ? bp : ap;
          }, preds[0]);
          paintBox(octx, best.bbox, best.class || 'pdf417', best.confidence);
          lastBBox = best.bbox; setHit(true);

          // --- Auto-captura ---
          if(isAuto && !captureCooldown){
            const thr = clamp(parseFloat($('#numThresh').val()) || 0.6, 0, 1);
            if(best.confidence >= thr){
              captureCooldown = true;
              // Dispara captura asincr√≥nica sin bloquear FPS
              setTimeout(async ()=>{
                await captureRoiFromCamera();
                const cooldownMs = Math.max(0, (parseFloat($('#numCooldown').val()) || 2.5) * 1000);
                setTimeout(()=>{ captureCooldown = false; }, cooldownMs);
              }, 0);
            }
          }
          // --- fin auto-captura ---

        } else { lastBBox = null; setHit(false); }
      }catch(e){ /* noop */ }
      updateFPS();
      rafId = requestAnimationFrame(loopDetect);
    }

    // ====== Capturar ROI (c√°mara) desde bbox detectado ======
    async function captureRoiFromCamera(){
      if(!running || !lastBBox || !video.videoWidth) {
        setStatus('No hay detecci√≥n activa para capturar','bad');
        return;
      }
      const vw = video.videoWidth, vh = video.videoHeight;
      const frame = document.createElement('canvas');
      frame.width = vw; frame.height = vh;
      const fctx = frame.getContext('2d', { willReadFrequently:true });
      fctx.drawImage(video, 0, 0, vw, vh);

      const { x, y, width, height } = lastBBox;
      const rx = Math.max(0, Math.round(x - width/2));
      const ry = Math.max(0, Math.round(y - height/2));
      const rw = Math.max(1, Math.round(width));
      const rh = Math.max(1, Math.round(height));

      const crop = document.createElement('canvas');
      crop.width = rw; crop.height = rh;
      const cctx = crop.getContext('2d');
      cctx.drawImage(frame, rx, ry, rw, rh, 0, 0, rw, rh);

      // Preview en panel
      roiCtx.clearRect(0,0,roiPreview.width,roiPreview.height);
      const scale = Math.min(roiPreview.width / rw, roiPreview.height / rh);
      const dw = Math.round(rw * scale), dh = Math.round(rh * scale);
      const dx = Math.round((roiPreview.width - dw)/2), dy = Math.round((roiPreview.height - dh)/2);
      roiCtx.drawImage(crop, 0, 0, rw, rh, dx, dy, dw, dh);

      const raw = await decodeFromCanvas(crop);
      if(raw){
        setStatus('C√≥digo detectado en ROI (c√°mara)','ok');
        const parsed = smartParse(raw); renderResult(parsed, raw);
      }else{
        setStatus('No se pudo decodificar el ROI (c√°mara). Intenta acercar/enfocar.','bad');
      }
    }

    // ====== Imagen (carga + preview) ======
    function loadImageFile(file){
      return new Promise((resolve,reject)=>{
        const reader = new FileReader();
        reader.onload = ()=>{
          const img = new Image();
          img.onload = ()=>{
            imgCanvasFull.width = img.naturalWidth; imgCanvasFull.height = img.naturalHeight;
            ifctx.drawImage(img, 0, 0);
            fitPreview(img);
            sourceMode = 'image'; imgLoaded = true;
            resolve();
          };
          img.onerror = reject;
          img.src = reader.result;
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }
    function fitPreview(img){
      const W = imgCanvasPreview.width = imgCanvasPreview.clientWidth || 640;
      const H = imgCanvasPreview.height = Math.round(W * (img.naturalHeight/img.naturalWidth));
      drawSize.w = W; drawSize.h = H;
      imgCtx.clearRect(0,0,W,H);
      imgCtx.drawImage(img, 0, 0, W, H);
      imgCanvasPreview.classList.remove('hidden');
      drawROIOverlay();
    }

    // ====== Detecci√≥n en imagen con Roboflow ======
    async function detectOnImage(){
      if (!imgCanvasFull.width) return null;
      const image = new CVImage(imgCanvasFull);
      try{
        const preds = await engine.infer(workerId, image);
        imgCtx.drawImage(imgCanvasFull, 0, 0, imgCanvasPreview.width, imgCanvasPreview.height);
        if (preds && preds.length){
          const best = preds.find(p => (p.class||'').toLowerCase().includes('pdf')) || preds[0];
          paintBBoxScaled(best.bbox, '#ffb347');
          setHit(true);
        } else {
          setHit(false);
        }
      }catch(e){ /* noop */ }
    }
    function paintBBoxScaled(bbox, color='#ffb347'){
      const sx = imgCanvasPreview.width / imgCanvasFull.width;
      const sy = imgCanvasPreview.height / imgCanvasFull.height;
      const ctx = imgCtx;
      ctx.save();
      ctx.lineWidth = 3; ctx.strokeStyle = color;
      ctx.strokeRect(
        bbox.x*sx - bbox.width*sx/2,
        bbox.y*sy - bbox.height*sy/2,
        bbox.width*sx,
        bbox.height*sy
      );
      ctx.restore();
    }

    // ====== ROI helpers (imagen) ======
    function roiToPx(r){
      return { x: Math.round(r.x * drawSize.w), y: Math.round(r.y * drawSize.h), w: Math.round(r.w * drawSize.w), h: Math.round(r.h * drawSize.h) };
    }
    function pxToRoi(px){
      return {
        x: Math.max(0, Math.min(1, px.x / drawSize.w)),
        y: Math.max(0, Math.min(1, px.y / drawSize.h)),
        w: Math.max(1/drawSize.w, Math.min(1, px.w / drawSize.w)),
        h: Math.max(1/drawSize.h, Math.min(1, px.h / drawSize.h)),
      };
    }

    function getHandleAt(mx, my, rect){
      const cx = rect.x + rect.w/2, cy = rect.y + rect.h/2;
      const pts = [
        {k:'nw', x:rect.x, y:rect.y},
        {k:'ne', x:rect.x+rect.w, y:rect.y},
        {k:'sw', x:rect.x, y:rect.y+rect.h},
        {k:'se', x:rect.x+rect.w, y:rect.y+rect.h},
        {k:'n',  x:cx, y:rect.y},
        {k:'s',  x:cx, y:rect.y+rect.h},
        {k:'w',  x:rect.x, y:cy},
        {k:'e',  x:rect.x+rect.w, y:cy},
      ];
      for(const p of pts){
        if(Math.abs(mx - p.x) <= HANDLE && Math.abs(my - p.y) <= HANDLE) return p.k;
      }
      if(mx >= rect.x && mx <= rect.x+rect.w && my >= rect.y && my <= rect.y+rect.h) return 'move';
      return null;
    }

    function drawHandles(rect){
      const ctx = imgCtx;
      const corners = [
        {x:rect.x, y:rect.y},
        {x:rect.x+rect.w, y:rect.y},
        {x:rect.x, y:rect.y+rect.h},
        {x:rect.x+rect.w, y:rect.y+rect.h},
      ];
      const edges = [
        {x:rect.x+rect.w/2, y:rect.y}, // n
        {x:rect.x+rect.w/2, y:rect.y+rect.h}, // s
        {x:rect.x, y:rect.y+rect.h/2}, // w
        {x:rect.x+rect.w, y:rect.y+rect.h/2}, // e
      ];
      ctx.save();
      ctx.fillStyle = '#0f6';
      for(const p of corners){ ctx.fillRect(p.x-3, p.y-3, 6, 6); }
      ctx.fillStyle = '#ffd866';
      for(const p of edges){ ctx.fillRect(p.x-3, p.y-3, 6, 6); }
      ctx.restore();
    }

    function drawROIOverlay(){
      if(!imgLoaded) return;
      const base = new Image();
      base.onload = ()=>{
        imgCtx.clearRect(0,0,imgCanvasPreview.width,imgCanvasPreview.height);
        imgCtx.drawImage(base, 0, 0, imgCanvasPreview.width, imgCanvasPreview.height);
        const rpx = roiToPx(roi);

        imgCtx.save();
        imgCtx.fillStyle = 'rgba(0,0,0,0.45)';
        imgCtx.beginPath();
        imgCtx.rect(0, 0, drawSize.w, drawSize.h);
        imgCtx.rect(rpx.x, rpx.y, rpx.w, rpx.h);
        imgCtx.fill('evenodd');
        imgCtx.restore();

        imgCtx.save();
        imgCtx.strokeStyle = '#0f6';
        imgCtx.lineWidth = 2;
        imgCtx.setLineDash([8,6]);
        imgCtx.strokeRect(rpx.x, rpx.y, rpx.w, rpx.h);
        imgCtx.restore();

        drawHandles(rpx);

        // actualizar vista previa ROI (imagen)
        const sx = Math.max(0, Math.round(roi.x * imgCanvasFull.width));
        const sy = Math.max(0, Math.round(roi.y * imgCanvasFull.height));
        const sw = Math.max(1, Math.round(roi.w * imgCanvasFull.width));
        const sh = Math.max(1, Math.round(roi.h * imgCanvasFull.height));
        roiCtx.clearRect(0,0,roiPreview.width,roiPreview.height);
        const scale = Math.min(roiPreview.width / sw, roiPreview.height / sh);
        const dw = Math.round(sw * scale), dh = Math.round(sh * scale);
        const dx = Math.round((roiPreview.width - dw)/2), dy = Math.round((roiPreview.height - dh)/2);
        roiCtx.drawImage(imgCanvasFull, sx, sy, sw, sh, dx, dy, dw, dh);
      };
      base.src = imgCanvasFull.toDataURL('image/png');
    }

    function getRoiPixels(){
      if (!imgLoaded || !imgCanvasFull.width) return null;
      const sx = Math.max(0, Math.round(roi.x * imgCanvasFull.width));
      const sy = Math.max(0, Math.round(roi.y * imgCanvasFull.height));
      const sw = Math.max(1, Math.round(roi.w * imgCanvasFull.width));
      const sh = Math.max(1, Math.round(roi.h * imgCanvasFull.height));
      const temp = document.createElement('canvas');
      temp.width = sw; temp.height = sh;
      const tctx = temp.getContext('2d');
      tctx.drawImage(imgCanvasFull, sx, sy, sw, sh, 0, 0, sw, sh);
      return temp;
    }

    // ====== Parsers ======
    function parseUSDL(str){
      const CodeToKey = { DCA:"jurisdictionVehicleClass", DCB:"jurisdictionRestrictionCodes", DCD:"jurisdictionEndorsementCodes", DBA:"dateOfExpiry", DCS:"lastName", DAC:"firstName", DAD:"middleName", DBD:"dateOfIssue", DBB:"dateOfBirth", DBC:"sex", DAY:"eyeColor", DAU:"height", DAG:"addressStreet", DAI:"addressCity", DAJ:"addressState", DAK:"addressPostalCode", DAQ:"documentNumber", DCF:"documentDiscriminator", DCG:"issuer", DDE:"lastNameTruncated", DDF:"firstNameTruncated", DDG:"middleNameTruncated", DAZ:"hairColor", DAH:"addressStreet2", DCI:"placeOfBirth", DCJ:"auditInformation", DCK:"inventoryControlNumber", DBN:"otherLastName", DBG:"otherFirstName", DBS:"otherSuffixName", DCU:"nameSuffix", DCE:"weightRange", DCL:"race", DCM:"standardVehicleClassification", DCN:"standardEndorsementCode", DCO:"standardRestrictionCode", DCP:"jurisdictionVehicleClassificationDescription", DCQ:"jurisdictionEndorsementCodeDescription", DCR:"jurisdictionRestrictionCodeDescription", DDA:"complianceType", DDB:"dateCardRevised", DDC:"dateOfExpiryHazmatEndorsement", DDD:"limitedDurationDocumentIndicator", DAW:"weightLb", DAX:"weightKg", DDH:"dateAge18", DDI:"dateAge19", DDJ:"dateAge21", DDK:"organDonor", DDL:"veteran" };
      const lines = String(str||'').trim().split(/\r?\n/).map(l => l.replace(/[^\t\n\r\x20-\x7E]/g, '').trim());
      const props = {}; let started=false;
      for(let i=0;i<lines.length;i++){
        const line = lines[i];
        if(!started){ if(line.indexOf('ANSI ')===0) { started=true; } continue; }
        const code = line.slice(0,3); const valueRaw = line.slice(3);
        const key = CodeToKey[code]; if(!key) continue;
        let value = valueRaw;
        if(code==='DBC') value = (value==='1')? 'M' : 'F';
        if(/^date/.test(key) && /^(\d{8})$/.test(value)) {
          const mm=value.slice(0,2), dd=value.slice(2,4), yy=value.slice(4);
          value = `${yy}-${mm}-${dd}`;
        }
        props[key] = value;
      }
      return Object.keys(props).length? props : null;
    }
    function parseDUI(text){
      const parts = String(text||'').split('||');
      if(parts.length<3) return null;
      const fieldNames = [
        "N√∫mero de DUI","Primer Apellido","Segundo Apellido y Nombres","Tipo de Documento","Firma Digital",
        "Lugar de Nacimiento","Municipio","Departamento","Nacionalidad","Sexo","Fecha de Nacimiento",
        "Fecha de Emisi√≥n","N√∫mero de Emisi√≥n","Categor√≠a","Fecha de Vencimiento","Segunda Firma Digital","C√≥digo de Verificaci√≥n"
      ];
      const out = {};
      for(let i=0;i<fieldNames.length;i++) out[fieldNames[i]] = (i<parts.length? parts[i] : 'No disponible');
      return out;
    }
    function smartParse(raw){
      const txt = String(raw||'');
      if(txt.includes('||')) return { kind:'DUI', data: parseDUI(txt) };
      const usd = parseUSDL(txt); if(usd) return { kind:'AAMVA', data: usd };
      return { kind:'raw', data: { raw: txt } };
    }
    function renderResult(parsed, raw){
      renderTable(parsed?.data || {});
      $('#txtJson').val(JSON.stringify(parsed?.data || {}, null, 2));
      $('#txtRaw').val(String(raw||''));
    }

    // ====== Eventos UI ======
    $('#btnStart').on('click', startCamera);
    $('#btnStop').on('click', stopCamera);
    $('#btnFlip').on('click', async ()=>{ 
      facingMode = (facingMode==='environment')? 'user' : 'environment';
      if(running) startCamera();
    });
    $('#btnCaptureCamROI').on('click', captureRoiFromCamera);

    // Auto-captura toggles
    $('#chkAuto').on('change', function(){ isAuto = !!this.checked; setStatus(isAuto?'Auto-captura ON':'Auto-captura OFF','info'); });
    $('#numThresh,#numCooldown').on('change', function(){
      const v = $(this).val();
      if(this.id==='numThresh') $(this).val(String(clamp(parseFloat(v)||0.6,0,1)));
      if(this.id==='numCooldown') $(this).val(String(clamp(parseFloat(v)||2.5,0,30)));
    });

    // Imagen
    $('#btnPick').on('click', ()=> document.getElementById('fileImage').click());
    $('#fileImage').on('change', async (e)=>{
      const f = e.target.files?.[0];
      if(!f){ imgCanvasPreview.classList.add('hidden'); return; }
      await loadImageFile(f);
      setStatus('Imagen cargada (puede ajustar el ROI y capturar)');
    });
    $('#btnDetectImg').on('click', detectOnImage);
    $('#btnProcessFull').on('click', async ()=>{
      if(!imgLoaded) return setStatus('Cargue una imagen primero','info');
      const temp = document.createElement('canvas');
      temp.width = imgCanvasFull.width; temp.height = imgCanvasFull.height;
      temp.getContext('2d').drawImage(imgCanvasFull, 0, 0);
      const raw = await decodeFromCanvas(temp);
      if(raw){ setStatus('C√≥digo detectado (imagen completa)','ok'); const parsed = smartParse(raw); renderResult(parsed, raw); }
      else setStatus('No se detect√≥ c√≥digo en la imagen completa','bad');
    });
    $('#btnProcessROI').on('click', async ()=>{
      if(!imgLoaded) return setStatus('Cargue una imagen primero','info');
      const roiCanvas = getRoiPixels();
      if(!roiCanvas) return setStatus('Defina un ROI v√°lido','info');
      const raw = await decodeFromCanvas(roiCanvas);
      if(raw){
        setStatus('C√≥digo detectado en ROI','ok');
        // mostrar preview del ROI (imagen)
        roiCtx.clearRect(0,0,roiPreview.width,roiPreview.height);
        const scale = Math.min(roiPreview.width / roiCanvas.width, roiPreview.height / roiCanvas.height);
        const dw = Math.round(roiCanvas.width * scale), dh = Math.round(roiCanvas.height * scale);
        const dx = Math.round((roiPreview.width - dw)/2), dy = Math.round((roiPreview.height - dh)/2);
        roiCtx.drawImage(roiCanvas, 0, 0, roiCanvas.width, roiCanvas.height, dx, dy, dw, dh);
        const parsed = smartParse(raw); renderResult(parsed, raw);
      }else setStatus('No se detect√≥ PDF417 en el ROI','bad');
    });
    $('#btnParse').on('click', ()=>{
      const raw = $('#txtRaw').val();
      const parsed = smartParse(raw);
      renderResult(parsed, raw);
      setStatus('Parseo completado','ok');
    });
    $('#btnClearRaw').on('click', ()=>{ $('#txtRaw').val(''); $('#txtJson').val(''); renderTable({}); });

    // ====== Interacci√≥n precisa (imagen) ======
    imgCanvasPreview.addEventListener('mousedown', (e)=>{
      if(!imgLoaded) return;
      const rect = imgCanvasPreview.getBoundingClientRect();
      const mx = e.clientX - rect.left, my = e.clientY - rect.top;
      const rpx = roiToPx(roi);
      action = getHandleAt(mx, my, rpx);
      start = {x:mx, y:my};
      startRoi = {...roi};
    });
    window.addEventListener('mousemove', (e)=>{
      if(!imgLoaded || !action) return;
      const rect = imgCanvasPreview.getBoundingClientRect();
      const mx = e.clientX - rect.left, my = e.clientY - rect.top;
      const dx = mx - start.x, dy = my - start.y;
      let rpx = roiToPx(startRoi);

      if(action==='move'){ rpx.x += dx; rpx.y += dy; }
      else{
        if(action?.includes('e')) rpx.w += dx;
        if(action?.includes('s')) rpx.h += dy;
        if(action?.includes('w')){ rpx.x += dx; rpx.w -= dx; }
        if(action?.includes('n')){ rpx.y += dy; rpx.h -= dy; }
      }
      rpx.w = Math.max(MIN_SIZE_PX, rpx.w);
      rpx.h = Math.max(MIN_SIZE_PX, rpx.h);
      rpx.x = Math.max(0, Math.min(drawSize.w - rpx.w, rpx.x));
      rpx.y = Math.max(0, Math.min(drawSize.h - rpx.h, rpx.y));
      roi = pxToRoi(rpx);
      drawROIOverlay();
    });
    window.addEventListener('mouseup', ()=>{ action=null; });

    // Touch (drag + pinch)
    imgCanvasPreview.addEventListener('touchstart', (e)=>{
      if(!imgLoaded) return;
      e.preventDefault();
      const touches = Array.from(e.touches);
      activeTouches.clear();
      touches.forEach(t=>activeTouches.set(t.identifier, {x:t.clientX, y:t.clientY}));

      if(touches.length===1){
        const rect = imgCanvasPreview.getBoundingClientRect();
        const mx = touches[0].clientX - rect.left, my = touches[0].clientY - rect.top;
        const rpx = roiToPx(roi);
        action = getHandleAt(mx, my, rpx) || 'move';
        start = {x:mx, y:my};
        startRoi = {...roi};
      }else if(touches.length===2){
        pinchStartDist = dist2(touches[0], touches[1]);
        pinchStartRoi = {...roi};
      }
    }, {passive:false});
    imgCanvasPreview.addEventListener('touchmove', (e)=>{
      if(!imgLoaded) return;
      e.preventDefault();
      const touches = Array.from(e.touches);
      if(touches.length===1 && action){
        const rect = imgCanvasPreview.getBoundingClientRect();
        const mx = touches[0].clientX - rect.left, my = touches[0].clientY - rect.top;
        const dx = mx - start.x, dy = my - start.y;
        let rpx = roiToPx(startRoi);

        if(action==='move'){ rpx.x += dx; rpx.y += dy; }
        else{
          if(action.includes('e')) rpx.w += dx;
          if(action.includes('s')) rpx.h += dy;
          if(action.includes('w')){ rpx.x += dx; rpx.w -= dx; }
          if(action.includes('n')){ rpx.y += dy; rpx.h -= dy; }
        }

        rpx.w = Math.max(MIN_SIZE_PX, rpx.w);
        rpx.h = Math.max(MIN_SIZE_PX, rpx.h);
        rpx.x = Math.max(0, Math.min(drawSize.w - rpx.w, rpx.x));
        rpx.y = Math.max(0, Math.min(drawSize.h - rpx.h, rpx.y));
        roi = pxToRoi(rpx);
        drawROIOverlay();
      } else if(touches.length===2 && pinchStartRoi){
        const d = dist2(touches[0], touches[1]);
        const scale = d / (pinchStartDist || d);
        const cx = pinchStartRoi.x + pinchStartRoi.w/2;
        const cy = pinchStartRoi.y + pinchStartRoi.h/2;
        let w = pinchStartRoi.w * scale;
        let h = pinchStartRoi.h * scale;
        w = Math.max(MIN_SIZE_PX/drawSize.w, w);
        h = Math.max(MIN_SIZE_PX/drawSize.h, h);
        let x = cx - w/2, y = cy - h/2;
        x = Math.max(0, Math.min(1 - w, x));
        y = Math.max(0, Math.min(1 - h, y));
        roi = {x,y,w,h};
        drawROIOverlay();
      }
    }, {passive:false});
    imgCanvasPreview.addEventListener('touchend', (e)=>{ e.preventDefault(); action=null; pinchStartRoi=null; activeTouches.clear(); }, {passive:false});
    function dist2(a,b){ const dx=a.clientX-b.clientX, dy=a.clientY-b.clientY; return Math.hypot(dx,dy); }

    // Teclado
    imgCanvasPreview.addEventListener('keydown', (e)=>{
      if(!imgLoaded) return;
      const step = e.shiftKey ? 5 : 1; // px
      const grow = e.shiftKey ? 6 : 2; // px por lado
      const rpx = roiToPx(roi);

      if(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','+','-','=', '_'].includes(e.key)) e.preventDefault();

      if(e.key==='ArrowLeft'){ rpx.x = Math.max(0, rpx.x - step); }
      if(e.key==='ArrowRight'){ rpx.x = Math.min(drawSize.w - rpx.w, rpx.x + step); }
      if(e.key==='ArrowUp'){ rpx.y = Math.max(0, rpx.y - step); }
      if(e.key==='ArrowDown'){ rpx.y = Math.min(drawSize.h - rpx.h, rpx.y + step); }

      if(e.key==='+' || e.key==='='){ // expandir
        rpx.x = Math.max(0, rpx.x - grow);
        rpx.y = Math.max(0, rpx.y - grow);
        rpx.w = Math.min(drawSize.w - rpx.x, rpx.w + grow*2);
        rpx.h = Math.min(drawSize.h - rpx.y, rpx.h + grow*2);
      }
      if(e.key==='-' || e.key==='_'){ // contraer
        rpx.x = Math.min(rpx.x + grow, drawSize.w - MIN_SIZE_PX);
        rpx.y = Math.min(rpx.y + grow, drawSize.h - MIN_SIZE_PX);
        rpx.w = Math.max(MIN_SIZE_PX, rpx.w - grow*2);
        rpx.h = Math.max(MIN_SIZE_PX, rpx.h - grow*2);
      }

      roi = pxToRoi(rpx);
      drawROIOverlay();
    });

    // Enfocar el canvas al hacer click para habilitar teclado
    imgCanvasPreview.addEventListener('click', ()=> imgCanvasPreview.focus());

    // ====== Inicio ======
    loadModel();
    initDecoder();

    // ====== Tabs ======
    const tabs = Array.from(document.querySelectorAll('.tab'));
    tabs.forEach(btn=>{
      btn.addEventListener('click', ()=>{
        tabs.forEach(b=>b.classList.remove('active'));
        btn.classList.add('active');
        const pane = btn.dataset.pane;
        document.getElementById('pane-img').classList.toggle('hidden', pane!=='pane-img');
        document.getElementById('pane-raw').classList.toggle('hidden', pane!=='pane-raw');
      });
    });

    // Helpers
    function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

  })();
  </script>
</body>
</html>


