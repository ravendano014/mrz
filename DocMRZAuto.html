<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>OCR de Documentos · MRZ + PDF417 · Cámara/Imagen · ROIs · Dark</title>

  <!-- ====== Librerías por CDN ====== -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/inferencejs@1.1.3"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
  <!-- ZXing (UMD) expone window.ZXing.* para códigos de barras (incluye PDF417) -->
  <script src="https://unpkg.com/@zxing/library@latest"></script>

  <style>
    :root{--bg:#0b0f14;--panel:#111820;--muted:#1a2230;--text:#e6eef7;--sub:#9fb3c8;--accent:#5ac8fa;--good:#34d399;--bad:#f87171;--warn:#fbbf24;--border:#1f2a3a}
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;padding:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji"}
    h1{font-size:1.1rem;margin:0 0 .25rem 0;color:var(--text)}
    .app{display:grid;grid-template-columns:360px 1fr;gap:12px;height:100%;}
    .left{padding:12px;background:var(--panel);border-right:1px solid var(--border);overflow:auto}
    .right{display:grid;grid-template-rows:auto auto 1fr auto auto;gap:12px;padding:12px}

    .bar{display:flex;flex-wrap:wrap;align-items:center;gap:8px;background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:10px}
    .bar h2{font-size:.95rem;margin:0 10px 0 0;color:var(--sub)}
    .bar .spacer{flex:1 1 auto}

    .statusbar{position:sticky;top:0;z-index:5}
    .statusline{font-size:.92rem}
    .badge{display:inline-flex;align-items:center;gap:6px;padding:3px 8px;border-radius:999px;border:1px solid var(--border);background:#0f1720}
    .ok{color:var(--good)}.warn{color:var(--warn)}.err{color:var(--bad)}
    .muted{color:#6b7a8c}

    .stage{position:relative;background:#05080c;border:1px solid var(--border);border-radius:12px;overflow:hidden;min-height:320px}
    .layer{position:absolute;inset:0}
    #video{width:100%;height:100%;object-fit:contain;background:#000}
    #imgPreview{width:100%;height:100%;object-fit:contain;display:none}
    #overlay{touch-action:none}

    .card{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:10px;min-height:0}
    .card h3{margin:0 0 .5rem 0;color:var(--sub);font-size:.95rem}

    .results{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    textarea.raw{width:100%;height:240px;background:#0a121a;color:var(--text);border:1px solid var(--border);border-radius:10px;padding:8px;resize:vertical}
    table{width:100%;border-collapse:collapse}
    th,td{border-bottom:1px solid var(--border);padding:6px 8px;text-align:left;vertical-align:top}
    th{color:var(--sub);font-weight:600}

    button,input[type=file],input[type=text],input[type=number],select{
      appearance:none;border:none;background:var(--panel);color:var(--text);
      padding:8px 10px;border-radius:10px;border:1px solid var(--border);cursor:pointer
    }
    input[type=text],input[type=number],select{width:100%;cursor:text}
    button:hover{border-color:var(--accent)}
    button.primary{background:linear-gradient(180deg, #132435, #0f1c2a);border-color:#223247}
    button.good{border-color:#17392c;background:#0e2b21}
    button.bad{border-color:#3b1e1e;background:#2a1414}
    button[disabled],input[disabled],select[disabled]{opacity:.55;cursor:not-allowed}

    .fps{position:absolute;bottom:10px;left:10px;background:rgba(0,0,0,.4);padding:4px 8px;border-radius:8px;border:1px solid var(--border);font-size:.8rem}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}

    /* Panel de resultados (máx 40% del ancho de pantalla) */
    .results-panel{width:100%;max-width:40vw;}
    .results-scroll{overflow:auto;max-height:260px}

    @media (max-width: 1100px){
      .app{grid-template-columns:1fr}
      .left{order:2}
      .right{order:1}
      .results{grid-template-columns:1fr}
      .results-panel{max-width:100%}
    }
  </style>
</head>
<body>
  <div class="app">
    <!-- LADO IZQUIERDO -->
    <aside class="left">
      <h1>OCR de Documentos</h1>

      <div class="card" style="margin-bottom:12px">
        <h3>ROIs (plantilla)</h3>
        <div class="status" id="roiCount" style="margin-bottom:6px">0 ROIs</div>
        <div class="bar" style="padding:8px">
          <button id="btnAddRoi">Agregar ROI</button>
          <button id="btnDeleteRoi" class="bad">Eliminar ROI</button>
          <button id="btnClearRois" class="bad">Limpiar ROIs</button>
        </div>
        <div class="bar" style="padding:8px;margin-top:8px">
          <button id="btnExport">Exportar JSON</button>
          <input type="file" id="fileImport" accept="application/json" />
        </div>
        <!-- Propiedades ROI -->
        <div class="bar" style="padding:8px;margin-top:8px;display:grid;grid-template-columns:1fr 1fr;gap:8px">
          <input id="roiName" type="text" placeholder="Nombre ROI" />
          <select id="roiType">
            <option value="text">text</option>
            <option value="image">image</option>
            <option value="mrz">mrz</option>
            <option value="pdf417">pdf417</option>
            <option value="barcode">barcode</option>
          </select>
          <input id="roiX" type="number" step="0.001" min="0" max="1" placeholder="x (0..1)" />
          <input id="roiY" type="number" step="0.001" min="0" max="1" placeholder="y (0..1)" />
          <input id="roiW" type="number" step="0.001" min="0.02" max="1" placeholder="w (0..1)" />
          <input id="roiH" type="number" step="0.001" min="0.02" max="1" placeholder="h (0..1)" />
        </div>
        <div class="status" style="margin-top:6px">
          Tip: Click para seleccionar · Arrastra para mover · Arrastra bordes/esquinas para redimensionar · Supr/Backspace borra.
        </div>
      </div>

      <div class="card" style="margin-bottom:12px">
        <h3>Extracción por ROI</h3>
        <div class="bar" style="padding:8px">
          <button id="btnExtractSelected" class="good">Extraer ROI Seleccionado</button>
          <button id="btnExtractAll">Extraer todos los ROIs</button>
        </div>
        <div class="status" style="margin-top:6px">
          Tipos: <span class="mono">text, image, mrz, pdf417, barcode</span>
        </div>
      </div>

      <div class="card">
        <h3>Modelos de detección</h3>
        <div class="status" style="display:grid;gap:6px">
          <div>Engine: <span id="sEngine" class="badge">—</span></div>
          <div>Modelo Doc: <span id="sModelDoc" class="badge">—</span></div>
          <div>Modelo MRZ: <span id="sModelMRZ" class="badge">—</span></div>
          <div>Modelo PDF417: <span id="sModelPDF" class="badge">—</span></div>
        </div>
      </div>
    </aside>

    <!-- LADO DERECHO -->
    <main class="right">
      <!-- Barra de estado superior -->
      <div class="bar statusbar" id="topStatus">
        <span class="statusline" id="statusLine"><span class="badge">Listo.</span></span>
        <div class="spacer"></div>
        <span class="badge mono">Guía</span>
        <span class="muted">1) Auto-Doc activo · 2) Captura/previa · 3) MRZ · 4) PDF417</span>
      </div>

      <!-- Cámara -->
      <div class="bar" id="cameraBar">
        <h2>Cámara</h2>
        <button id="btnStart" class="primary">Iniciar</button>
        <button id="btnStop">Detener</button>
        <button id="btnShot" class="good">Capturar Imagen</button>
        <button id="btnShotDoc" class="good">Capturar solo Documento</button>

        <div class="spacer"></div>

        <label class="status" style="display:flex;align-items:center;gap:8px">
          <input type="checkbox" id="chkAutoDoc" /> Auto-detectar Documento
        </label>

        <label class="status" style="display:flex;align-items:center;gap:6px">
          <input type="checkbox" id="chkAutoMrzCam" checked />
          Auto-MRZ (cámara)
        </label>

        <label class="status" style="display:flex;align-items:center;gap:6px">
          Intervalo (ms)
          <input type="number" id="mrzInterval" value="800" min="200" step="100" style="width:90px" />
        </label>

        <span id="fps" class="badge mono">FPS: <span id="fpsVal">—</span></span>
      </div>

      <!-- Stage -->
      <section id="stage" class="stage">
        <video id="video" class="layer" autoplay muted playsinline></video>
        <img id="imgPreview" class="layer" alt="Previsualización" />
        <canvas id="overlay" class="layer"></canvas>
        <div class="fps mono" id="fpsOverlay">— fps</div>
      </section>

      <!-- Imagen -->
      <div class="bar" id="imageBar">
        <h2>Imagen</h2>
        <input type="file" id="file" accept="image/*" />
        <button id="btnParseFull">Extraer y Parsear (Imagen Completa)</button>
        <button id="btnDetectMRZ" class="primary">Detectar MRZ en Imagen</button>
        <button id="btnDetectPDF" class="primary">Detectar PDF417 en Imagen</button>
        <div class="spacer"></div>
        <label class="status" style="display:flex;align-items:center;gap:8px">
          <input type="checkbox" id="chkAutoMRZ" checked /> Auto-MRZ al cargar/capturar
        </label>
        <label class="status" style="display:flex;align-items:center;gap:8px">
          <!-- REQUISITO: Auto-PDF417 desactivado inicialmente -->
          <input type="checkbox" id="chkAutoPDF" /> Auto-PDF417 al cargar/capturar
        </label>
      </div>

      <!-- Resultados -->
      <section class="results">
        <div class="card">
          <h3>Texto crudo OCR</h3>
          <textarea id="raw" class="raw" placeholder="Aquí aparecerá el texto crudo…"></textarea>
          <div style="margin-top:8px">
            <button id="btnParseRaw" title="Parsear el contenido actual del área de texto sin volver a ejecutar OCR">Parsear Texto Crudo</button>
          </div>
        </div>

        <!-- Panel de resultados (máx 40% ancho pantalla) -->
        <div class="card results-panel">
          <h3>Datos parseados</h3>
          <div id="status" class="status">Esperando extracción…</div>

          <!-- PDF417 (arriba) -->
          <div id="pdf417Summary" class="status hidden" style="margin-top:8px"></div>
          <div id="pdf417Error" class="status err hidden" style="margin:6px 0 0 0"></div>
          <div id="pdf417Table" class="results-scroll" style="margin-top:6px"></div>

          <!-- MRZ (debajo de PDF417) -->
          <div id="mrzSummary" class="status hidden" style="margin-top:14px"></div>
          <div id="mrzTable" class="results-scroll" style="margin-top:6px"></div>

          <!-- Tabla de Resultados (ROIs) debajo -->
          <div style="margin-top:14px">
            <div class="status"><strong>Tabla de Resultados (ROIs)</strong></div>
            <div id="roiResults" class="results-scroll" style="margin-top:6px"></div>
          </div>
        </div>
      </section>
    </main>
  </div>

  <!-- =============== LÓGICA =============== -->
  <script>
    /* ===========================================================
       Bloqueo/Desbloqueo UI + Barra de estado
    ============================================================ */
    const $statusLine = document.getElementById('statusLine');

    function setStatusBar(msg, cls=''){
      $statusLine.innerHTML = `<span class="badge ${cls}">${msg}</span>`;
    }

    function setUIEnabled(on){
      const disable = !on;
      document.querySelectorAll('button, input, select').forEach(el=>{
        // No bloquear la barra de estado
        if(el.closest('#topStatus')) return;
        el.disabled = disable;
      });
    }

    function step(msg){ setStatusBar(msg,''); }
    function stepOk(msg){ setStatusBar(msg,'ok'); }
    function stepWarn(msg){ setStatusBar(msg,'warn'); }
    function stepErr(msg){ setStatusBar(msg,'err'); }

    // ====== Estado global
    const state = {
      stream: null,
      running: false,
      usingImage: false,
      lastDocDetections: [],
      selectedRoiId: null,
      rois: [],
      engine: null,
      docWorkerId: null,
      mrzWorkerId: null,
      pdfWorkerId: null,
      activeBitmap: null,
      activeNatural: {w:0,h:0},

      autoMrzCam: true,
      mrzTickMs: 800,
      mrzBusy: false,
      lastMrzTs: 0,
      mrzStableBox: null,
      mrzStableHits: 0,
      mrzCooldownUntil: 0,
      mrzAutoRoiId: null,

      pdfAutoRoiId: null,

      // Control de transición MRZ → PDF417
      pdfLoadedAfterMrz: false
    };

    // ====== DOM refs (mantenidos)
    const $video = document.getElementById('video');
    const $imgPreview = document.getElementById('imgPreview');
    const $overlay = document.getElementById('overlay');
    const ctx = $overlay.getContext('2d');
    const $fpsOverlay = document.getElementById('fpsOverlay');
    const $fpsVal = document.getElementById('fpsVal');
    const $sEngine = document.getElementById('sEngine');
    const $sModelDoc = document.getElementById('sModelDoc');
    const $sModelMRZ = document.getElementById('sModelMRZ');
    const $sModelPDF = document.getElementById('sModelPDF');
    const $raw = document.getElementById('raw');
    const $status = document.getElementById('status');
    const $roiCount = document.getElementById('roiCount');
    const $roiName = document.getElementById('roiName');
    const $roiType = document.getElementById('roiType');
    const $roiX = document.getElementById('roiX');
    const $roiY = document.getElementById('roiY');
    const $roiW = document.getElementById('roiW');
    const $roiH = document.getElementById('roiH');

    const $chkAutoDoc = document.getElementById('chkAutoDoc');
    const $chkAutoMrzCam = document.getElementById('chkAutoMrzCam');
    const $mrzInterval = document.getElementById('mrzInterval');
    const $chkAutoMRZ = document.getElementById('chkAutoMRZ');
    const $chkAutoPDF = document.getElementById('chkAutoPDF');

    // Resultados específicos
    const pdf417Summary = document.getElementById('pdf417Summary');
    const pdf417Error   = document.getElementById('pdf417Error');
    const pdf417Table   = document.getElementById('pdf417Table');
    const mrzSummary    = document.getElementById('mrzSummary');
    const mrzTable      = document.getElementById('mrzTable');
    const roiResults    = document.getElementById('roiResults');

    /* ===========================================================
       InferenceJS: carga engine + modelos (Doc + MRZ) al inicio
       PDF417 se cargará más adelante (tras MRZ)
    ============================================================ */
    async function initEngine(){
      try{
        step('Inicializando engine…');
        $sEngine.textContent = 'inicializando…';
        state.engine = new inferencejs.InferenceEngine();
        $sEngine.textContent = 'listo';
        stepOk('Engine listo');

        // 1) MODELO DOCUMENTO (para autodetección)
        step('Cargando modelo de Documento…');
        $sModelDoc.textContent = 'cargando…';
        state.docWorkerId = await state.engine.startWorker(
          'react-project-wdxr6',
          '1',
          'rf_hHUmNcZwoGhdPO3kyAlI6YY4R4m2'
        );
        $sModelDoc.textContent = 'OK';
        stepOk('Modelo de Documento listo');

        // 2) MODELO MRZ
        step('Cargando modelo MRZ…');
        $sModelMRZ.textContent = 'cargando…';
        state.mrzWorkerId = await state.engine.startWorker(
          'mrz-ye7hu-5jxuj',
          '1',
          'rf_hHUmNcZwoGhdPO3kyAlI6YY4R4m2'
        );
        $sModelMRZ.textContent = 'OK';
        stepOk('Modelo MRZ listo');

        // Importante: NO cargar PDF417 aquí — se cargará tras MRZ
        $sModelPDF.textContent = '—';
      }catch(err){
        console.error(err);
        stepErr('Error al inicializar modelos');
        $sEngine.textContent = 'error';
        if(!state.mrzWorkerId) $sModelMRZ.textContent = 'error';
      }
    }

    async function loadPDF417AfterMRZ(){
      if(state.pdfWorkerId) return; // ya cargado
      try{
        step('Descargando modelo de Documento para liberar memoria…');
        if(state.docWorkerId){
          await state.engine.stopWorker(state.docWorkerId).catch(()=>{});
          state.docWorkerId = null;
          $sModelDoc.textContent = '—';
        }
        stepOk('Modelo de Documento descargado');

        step('Cargando modelo PDF417…');
        $sModelPDF.textContent = 'cargando…';
        state.pdfWorkerId = await state.engine.startWorker(
          'pdf417-kl4vz-hl0le',
          '1',
          'rf_hHUmNcZwoGhdPO3kyAlI6YY4R4m2'
        );
        $sModelPDF.textContent = 'OK';
        stepOk('Modelo PDF417 listo');

        state.pdfLoadedAfterMrz = true;

        // Preguntar si desea activar Auto-PDF417
        const wantAuto = confirm('Modelo PDF417 listo. ¿Deseas activar Auto-PDF417 al cargar/capturar?');
        if(wantAuto){
          $chkAutoPDF.checked = true;
          stepOk('Auto-PDF417 activado por el usuario');
        }else{
          stepWarn('Auto-PDF417 permanece desactivado');
        }
      }catch(e){
        console.error(e);
        $sModelPDF.textContent = 'error';
        stepErr('Error cargando PDF417');
      }
    }

    /* ===========================================================
       Overlay/resize (igual que antes)
    ============================================================ */
    function resizeOverlay(){
      const host = state.usingImage ? $imgPreview : $video;
      const w = host.clientWidth || host.getBoundingClientRect().width;
      const h = host.clientHeight || host.getBoundingClientRect().height;
      $overlay.width  = Math.round(w * devicePixelRatio);
      $overlay.height = Math.round(h * devicePixelRatio);
      $overlay.style.width  = w + 'px';
      $overlay.style.height = h + 'px';
      drawOverlay();
    }
    addEventListener('resize', ()=>setTimeout(resizeOverlay,50));

    /* ===========================================================
       Cámara
    ============================================================ */
    async function startCamera(){
      try{
        state.stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'},audio:false});
        $video.srcObject = state.stream;
        await $video.play();
        state.running = true;
        state.usingImage = false;
        $imgPreview.style.display = 'none';
        $video.style.display = 'block';
        requestAnimationFrame(loop);
        setTimeout(resizeOverlay, 150);
      }catch(err){ console.error(err); }
    }
    function stopCamera(){
      state.running = false;
      if(state.stream){
        state.stream.getTracks().forEach(t=>t.stop());
        state.stream = null;
      }
    }

    /* ===========================================================
       Cargar imagen (mantiene funcionalidad)
    ============================================================ */
    document.getElementById('file').addEventListener('change', async (e)=>{
      const f = e.target.files?.[0]; if(!f) return;
      const url = URL.createObjectURL(f);
      $imgPreview.src = url;
      $imgPreview.onload = async ()=>{
        URL.revokeObjectURL(url);
        state.usingImage = true;
        $video.style.display='none';
        $imgPreview.style.display='block';
        const bmp = await imageBitmapFromImg($imgPreview);
        state.activeBitmap = bmp; state.activeNatural={w:bmp.width,h:bmp.height};
        resizeOverlay();

        // REGLA: Auto-MRZ activo; Auto-PDF417 inicialmente desactivado
        if($chkAutoMRZ.checked) { detectMRZFlow('Imagen cargada'); }
        if($chkAutoPDF.checked) { detectPDF417Flow('Imagen cargada'); }
      };
    });

    /* ===========================================================
       Bucle principal + Auto-Doc y Auto-MRZ cámara
    ============================================================ */
    let frames=0, lastFpsTs=0, lastDocPromptTs=0;
    async function loop(ts){
      if(!state.running) return;
      if(!$video.videoWidth){ requestAnimationFrame(loop); return; }

      frames++; if(ts-lastFpsTs>1000){
        const fps = Math.round(frames*1000/(ts-lastFpsTs));
        $fpsOverlay.textContent = fps+' fps';
        $fpsVal.textContent = fps;
        frames=0; lastFpsTs=ts;
      }

      const w=$video.videoWidth,h=$video.videoHeight;
      const bmp = await createImageBitmap($video, {resizeWidth:w,resizeHeight:h});
      state.activeBitmap = bmp; state.activeNatural={w,h};
      drawOverlay();

      // Auto-detect Doc
      if($chkAutoDoc.checked && state.docWorkerId){
        try{
          const cvimg = new inferencejs.CVImage($video);
          const preds = await state.engine.infer(state.docWorkerId, cvimg);
          state.lastDocDetections = preds||[];
          drawOverlay();
          const best = _.maxBy(state.lastDocDetections, p=>p.confidence||0);
          if(best && (best.confidence||0) >= 0.65 && ts-lastDocPromptTs>1200){
            lastDocPromptTs = ts;
            confirmCapture(best);
          }
        }catch(e){ console.warn('infer doc error', e); }
      }

      // Auto-MRZ (cámara) con throttling
      if(state.mrzWorkerId && $chkAutoMrzCam.checked){
        const now = performance.now();
        const interval = Math.max(200, parseInt($mrzInterval.value||'800',10));
        if(now - (state.lastMrzTs||0) >= interval){
          state.lastMrzTs = now;
          autoMrzTick().catch(console.warn);
        }
      }

      requestAnimationFrame(loop);
    }

    async function autoMrzTick(){
      const cvimg = new inferencejs.CVImage($video);
      const preds = await state.engine.infer(state.mrzWorkerId, cvimg).catch(()=>null);
      if(!preds?.length) return;

      const best = _.maxBy(preds, p=>p.confidence||0);
      if(!best) return;

      const roi = ensureAutoMrzRoi(best);

      if(best.confidence >= 0.70){
        const now = performance.now();
        if(now < state.mrzCooldownUntil) return;

        if(isStableBox(best.bbox, state.mrzStableBox, state.activeNatural)){
          state.mrzStableHits++;
        }else{
          state.mrzStableBox = {...best.bbox};
          state.mrzStableHits = 1;
        }

        if(state.mrzStableHits >= 3){
          state.mrzStableHits = 0;
          await extractAndReportROI(roi, 'Auto-MRZ cámara');
          state.mrzCooldownUntil = now + 5000;
        }
      }
    }

    /* ===========================================================
       Helpers de ROI y dibujo (sin cambios sustanciales)
    ============================================================ */
    function drawOverlay(){
      const view = $overlay.getBoundingClientRect();
      const viewW = view.width, viewH = view.height;

      ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
      ctx.clearRect(0,0,$overlay.width,$overlay.height);

      // Detecciones de documento
      for(const p of state.lastDocDetections){
        const rect = bboxToOverlayRect(p.bbox);
        ctx.strokeStyle = '#5ac8fa';
        ctx.lineWidth = 2;
        ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
        ctx.fillStyle = 'rgba(90,200,250,.12)';
        ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
        ctx.fillStyle = '#cfe9fb';
        ctx.font = '12px ui-monospace';
        const tag = `${p.class||'doc'} ${(p.confidence||0).toFixed(2)}`;
        ctx.fillText(tag, rect.x+6, rect.y+14);
      }

      roisDraw({width:viewW, height:viewH});
    }

    function bboxToOverlayRect(bbox){
      const view = $overlay.getBoundingClientRect();
      const viewW = view.width, viewH = view.height;
      const natW = state.activeNatural.w || 1, natH = state.activeNatural.h || 1;
      const scale = Math.min(viewW/natW, viewH/natH);
      const offX = (viewW - natW*scale)/2, offY = (viewH - natH*scale)/2;
      const sx = offX + (bbox.x - bbox.width/2) * scale;
      const sy = offY + (bbox.y - bbox.height/2) * scale;
      const sw = bbox.width * scale, sh = bbox.height * scale;
      return {x:sx,y:sy,w:sw,h:sh};
    }

    function roisDraw(view){
      for(const roi of state.rois){
        const x = roi.x*view.width, y=roi.y*view.height, w=roi.w*view.width, h=roi.h*view.height;
        const selected = (roi.id===state.selectedRoiId);

        ctx.strokeStyle = selected?'#34d399':'#9fb3c8';
        ctx.lineWidth = selected?2:1.5;
        ctx.strokeRect(x,y,w,h);
        if(selected){
          ctx.fillStyle='rgba(52,211,153,.07)';
          ctx.fillRect(x,y,w,h);
        }

        ctx.fillStyle='#cfe9fb';
        ctx.font='12px ui-monospace';
        ctx.fillText(`${roi.name||('ROI '+roi.id)} · ${roi.type||'text'}`, x+6, y+14);

        if(selected){
          const H=10;
          const pts=[
            [x,y], [x+w/2-H/2,y], [x+w-H,y],
            [x+w-H,y+h/2-H/2], [x+w-H,y+h-H],
            [x+w/2-H/2,y+h-H], [x,y+h-H],
            [x,y+h/2-H/2]
          ];
          ctx.fillStyle='#5ac8fa';
          pts.forEach(([px,py])=>{
            ctx.fillRect(px,py,H,H);
            ctx.strokeStyle='#00121c'; ctx.lineWidth=1;
            ctx.strokeRect(px,py,H,H);
          });
        }
      }
    }

    function updateRoiCount(){ document.getElementById('roiCount').textContent = state.rois.length + ' ROIs'; }

    function syncRoiPropsPanel(){
      const a = state.rois.find(r=>r.id===state.selectedRoiId);
      const disabled = !a;
      [$roiName,$roiType,$roiX,$roiY,$roiW,$roiH].forEach(inp=>{ inp.disabled = disabled; });
      if(a){
        $roiName.value = a.name || '';
        $roiType.value = a.type || 'text';
        $roiX.value = a.x.toFixed(3);
        $roiY.value = a.y.toFixed(3);
        $roiW.value = a.w.toFixed(3);
        $roiH.value = a.h.toFixed(3);
      }else{
        $roiName.value=''; $roiType.value='text'; $roiX.value=''; $roiY.value=''; $roiW.value=''; $roiH.value='';
      }
    }

    function addRoiFromRect(px,py,pw,ph){
      const r = $overlay.getBoundingClientRect();
      const rx = px / r.width,  ry = py / r.height;
      const rw = pw / r.width,  rh = ph / r.height;

      const roi = {
        id: _.uniqueId('roi_'),
        name: 'ROI',
        type: 'text',
        x: Math.max(0, rx),
        y: Math.max(0, ry),
        w: Math.max(0.02, Math.min(1, rw)),
        h: Math.max(0.02, Math.min(1, rh))
      };
      state.rois.push(roi);
      state.selectedRoiId = roi.id;
      updateRoiCount(); drawOverlay(); syncRoiPropsPanel();
      return roi;
    }

    function pickRoi(px,py){
      const r = $overlay.getBoundingClientRect();
      const rx = px / r.width, ry = py / r.height;
      for(let i=state.rois.length-1;i>=0;i--){
        const a=state.rois[i];
        if(rx>=a.x && ry>=a.y && rx<=a.x+a.w && ry<=a.y+a.h){ return a; }
      }
      return null;
    }

    function removeSelected(){
      if(!state.selectedRoiId) return;
      _.remove(state.rois, r=>r.id===state.selectedRoiId);
      state.selectedRoiId = null; updateRoiCount(); drawOverlay(); syncRoiPropsPanel();
    }

    // Interacción ROIs
    const drag = {mode:null, roi:null, origin:{x:0,y:0}, handle:null};
    function overlayPointFromEvent(e){
      const r = $overlay.getBoundingClientRect();
      const pt = (e.touches? e.touches[0]: e);
      const x = Math.min(Math.max(pt.clientX - r.left, 0), r.width);
      const y = Math.min(Math.max(pt.clientY - r.top,  0), r.height);
      return {x,y};
    }
    function handleAt(roi,px,py){
      const r = $overlay.getBoundingClientRect();
      const x = roi.x*r.width, y=roi.y*r.height, w=roi.w*r.width, h=roi.h*r.height;
      const H=12;
      const within=(ax,ay)=> px>=ax && py>=ay && px<=ax+H && py<=ay+H;
      if(within(x,y)) return 'nw';
      if(within(x+w/2-H/2,y)) return 'n';
      if(within(x+w-H,y)) return 'ne';
      if(within(x+w-H,y+h/2-H/2)) return 'e';
      if(within(x+w-H,y+h-H)) return 'se';
      if(within(x+w/2-H/2,y+h-H)) return 's';
      if(within(x,y+h-H)) return 'sw';
      if(within(x,y+h/2-H/2)) return 'w';
      return null;
    }
    function onDown(e){
      const pt = overlayPointFromEvent(e);
      const pick = pickRoi(pt.x,pt.y);
      if(pick){
        state.selectedRoiId = pick.id; drawOverlay(); syncRoiPropsPanel();
        const h = handleAt(pick, pt.x, pt.y);
        drag.mode = h? 'resize':'move'; drag.roi = _.cloneDeep(pick); drag.origin={x:pt.x,y:pt.y}; drag.handle=h; e.preventDefault();
      }else{
        drag.mode='new'; drag.origin={x:pt.x, y:pt.y}; drag.roi=null; e.preventDefault();
      }
    }
    function onMove(e){
      if(!drag.mode) return;
      const pt = overlayPointFromEvent(e); const dx=pt.x-drag.origin.x, dy=pt.y-drag.origin.y;
      const r = $overlay.getBoundingClientRect();

      if(drag.mode==='new'){
        drawOverlay();
        ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
        ctx.strokeStyle='#34d399'; ctx.lineWidth=2; ctx.setLineDash([6,6]);
        ctx.strokeRect(drag.origin.x, drag.origin.y, dx, dy);
        ctx.setLineDash([]);
      }
      if(drag.mode==='move' && drag.roi){
        const a = _.find(state.rois, {id: state.selectedRoiId}); if(!a) return;
        const rx = dx / r.width, ry = dy / r.height;
        a.x = _.clamp(drag.roi.x + rx, 0, 1 - a.w);
        a.y = _.clamp(drag.roi.y + ry, 0, 1 - a.h);
        drawOverlay(); syncRoiPropsPanel();
      }
      if(drag.mode==='resize' && drag.roi){
        const a = _.find(state.rois, {id: state.selectedRoiId}); if(!a) return;
        const rx = dx / r.width, ry = dy / r.height;
        let {x,y,w,h} = drag.roi;
        const hnd = drag.handle;
        if(hnd==='n'||hnd==='ne'||hnd==='nw'){ h = _.clamp(h - ry, 0.02, 1); y = _.clamp(y + ry, 0, y+h); }
        if(hnd==='s'||hnd==='se'||hnd==='sw'){ h = _.clamp(h + ry, 0.02, 1); }
        if(hnd==='w'||hnd==='nw'||hnd==='sw'){ w = _.clamp(w - rx, 0.02, 1); x = _.clamp(x + rx, 0, x+w); }
        if(hnd==='e'||hnd==='ne'||hnd==='se'){ w = _.clamp(w + rx, 0.02, 1); }
        a.x=x; a.y=y; a.w=w; a.h=h; drawOverlay(); syncRoiPropsPanel();
      }
      e.preventDefault();
    }
    function onUp(e){
      if(drag.mode==='new'){
        const pt = overlayPointFromEvent(e); const x=Math.min(drag.origin.x, pt.x); const y=Math.min(drag.origin.y, pt.y);
        const w=Math.abs(pt.x-drag.origin.x); const h=Math.abs(pt.y-drag.origin.y);
        if(w>10 && h>10) addRoiFromRect(x,y,w,h);
      }
      drag.mode=null; drag.roi=null; drag.handle=null;
    }
    $overlay.addEventListener('mousedown', onDown); $overlay.addEventListener('mousemove', onMove); $overlay.addEventListener('mouseup', onUp);
    $overlay.addEventListener('touchstart', onDown, {passive:false}); $overlay.addEventListener('touchmove', onMove, {passive:false}); $overlay.addEventListener('touchend', onUp);
    addEventListener('keydown', (e)=>{ if(e.key==='Delete' || e.key==='Backspace') removeSelected(); });

    // Inputs/props ROI
    [$roiName,$roiType,$roiX,$roiY,$roiW,$roiH].forEach(inp=>{
      inp.addEventListener('input', ()=>{
        const a = state.rois.find(r=>r.id===state.selectedRoiId);
        if(!a) return;
        if(inp===$roiName){ a.name = $roiName.value; }
        else if(inp===$roiType){ a.type = $roiType.value; }
        else{
          const v = _.clamp(parseFloat(inp.value||'0')||0, 0, 1);
          if(inp===$roiX) a.x = v;
          if(inp===$roiY) a.y = v;
          if(inp===$roiW) a.w = Math.max(0.02, v);
          if(inp===$roiH) a.h = Math.max(0.02, v);
        }
        drawOverlay();
      });
    });
    syncRoiPropsPanel();

    // ====== Exportar / Importar
    document.getElementById('btnExport').addEventListener('click',()=>{
      const data = { schema:'roi-template:v1', size: state.activeNatural, rois: state.rois };
      const blob = new Blob([JSON.stringify(data,null,2)], {type:'application/json'});
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'plantilla-roi.json'; a.click();
      setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
    });
    document.getElementById('fileImport').addEventListener('change', async (e)=>{
      const f=e.target.files?.[0]; if(!f) return; const txt = await f.text();
      try{
        const j = JSON.parse(txt);
        if(j && Array.isArray(j.rois)) { state.rois = j.rois.map(r=>({type:'text',...r})); updateRoiCount(); drawOverlay(); syncRoiPropsPanel(); }
      }catch(err){ alert('JSON inválido'); }
    });

    // ====== Botones principales
    document.getElementById('btnStart').addEventListener('click', startCamera);
    document.getElementById('btnStop').addEventListener('click', stopCamera);
    document.getElementById('btnShot').addEventListener('click', async ()=>{
      if(!$video.videoWidth && !$imgPreview.complete) return;
      const bmp = state.usingImage ? await imageBitmapFromImg($imgPreview) : await createImageBitmap($video);
      await showPreviewBitmap(bmp);
    });
    document.getElementById('btnShotDoc').addEventListener('click', async ()=>{
      if(!state.docWorkerId) return alert('Modelo de documento no listo');
      const host = state.usingImage ? $imgPreview : $video;
      const preds = await state.engine.infer(state.docWorkerId, new inferencejs.CVImage(host));
      if(!preds?.length) return alert('No se detectó documento');
      const best = _.maxBy(preds, p=>p.confidence||0);
      const bmp = state.usingImage ? await imageBitmapFromImg($imgPreview) : await createImageBitmap($video);
      state.activeBitmap = bmp; state.activeNatural={w:bmp.width,h:bmp.height};
      const crop = cropFromDetection(best);
      await showPreviewBitmap(crop);
      runOCROnActive('Captura de documento');
    });

    // ====== MRZ: detección en imagen
    document.getElementById('btnDetectMRZ').addEventListener('click', ()=>detectMRZFlow('Detección manual'));
    async function detectMRZFlow(context=''){
      if(!state.mrzWorkerId) return alert('Modelo MRZ no listo');
      const host = state.usingImage ? $imgPreview : $video;
      if(!state.usingImage && !$video.videoWidth){ return alert('No hay imagen/cámara lista'); }

      const bmp = state.usingImage ? await imageBitmapFromImg($imgPreview) : await createImageBitmap($video);
      state.activeBitmap = bmp; state.activeNatural={w:bmp.width,h:bmp.height};

      setStatus(`Buscando MRZ… ${context?'(' + context + ')':''}`);
      try{
        const preds = await state.engine.infer(state.mrzWorkerId, new inferencejs.CVImage(host));
        if(!preds?.length){ setStatus('No se detectó MRZ.', true); return; }
        const best = _.maxBy(preds, p=>p.confidence||0);

        const roi = ensureAutoMrzRoi(best);
        state.selectedRoiId = roi.id;
        syncRoiPropsPanel(); drawOverlay();

        await extractAndReportROI(roi, 'Detección estática');
      }catch(e){
        console.error(e);
        setStatus('Error al inferir MRZ.', true);
      }
    }

    // ====== PDF417: detección en imagen
    document.getElementById('btnDetectPDF').addEventListener('click', ()=>detectPDF417Flow('Detección manual'));
    async function detectPDF417Flow(context=''){
      if(!state.pdfWorkerId) return alert('Modelo PDF417 no listo');
      const host = state.usingImage ? $imgPreview : $video;
      if(!state.usingImage && !$video.videoWidth){ return alert('No hay imagen/cámara lista'); }

      const bmp = state.usingImage ? await imageBitmapFromImg($imgPreview) : await createImageBitmap($video);
      state.activeBitmap = bmp; state.activeNatural={w:bmp.width,h:bmp.height};

      setStatus(`Buscando PDF417… ${context?'(' + context + ')':''}`);
      try{
        const preds = await state.engine.infer(state.pdfWorkerId, new inferencejs.CVImage(host));
        if(!preds?.length){ setStatus('No se detectó PDF417.', true); return; }
        const best = _.maxBy(preds, p=>p.confidence||0);

        const roi = ensureAutoPdfRoi(best);
        state.selectedRoiId = roi.id;
        syncRoiPropsPanel(); drawOverlay();

        roi.type = 'pdf417';
        await extractAndReportROI(roi, 'Detección PDF417');
      }catch(e){
        console.error(e);
        setStatus('Error al inferir PDF417.', true);
      }
    }

    // ====== OCR completo
    document.getElementById('btnParseFull').addEventListener('click', ()=>{
      if(!state.usingImage){ alert('Primero sube una imagen o captura una'); return; }
      runOCROnActive('Imagen completa');
    });

    async function imageBitmapFromImg(img){
      const {naturalWidth:w, naturalHeight:h} = img; return await createImageBitmap(img, {resizeWidth:w, resizeHeight:h});
    }

    async function runOCROnActive(contextLabel){
      if(!state.activeBitmap){ alert('No hay imagen activa'); return; }
      setStatus(`Procesando OCR (${contextLabel})…`);
      const c = new OffscreenCanvas(state.activeBitmap.width, state.activeBitmap.height);
      const g = c.getContext('2d'); g.drawImage(state.activeBitmap,0,0);
      const blob = await c.convertToBlob({type:'image/png', quality:0.92});
      const imgUrl = URL.createObjectURL(blob);
      try{
        const worker = await Tesseract.createWorker('spa+eng');
        const { data:{ text } } = await worker.recognize(imgUrl);
        await worker.terminate();
        $raw.value = (text||'').trim();
        parseToTable($raw.value);
        setStatus('OCR completado.');
      }catch(err){ console.error(err); setStatus('Error en OCR', true); }
      finally{ URL.revokeObjectURL(imgUrl); }
    }

    function setStatus(msg,isErr){ $status.innerHTML = `<span class="badge ${isErr?'err':'ok'}">${msg}</span>`; }

    /* ===========================================================
       ROI → natural px + canvas helpers (igual)
    ============================================================ */
    function mapRoiToNatural(roi){
      const view = $overlay.getBoundingClientRect();
      const viewW = view.width, viewH = view.height;
      const natW = state.activeNatural.w, natH = state.activeNatural.h;
      if(!natW || !natH) return {x:0,y:0,w:0,h:0};
      const scale = Math.min(viewW/natW, viewH/natH);
      const contentW = natW * scale, contentH = natH * scale;
      const offX = (viewW - contentW)/2, offY = (viewH - contentH)/2;
      const ox = roi.x*viewW, oy = roi.y*viewH, ow = roi.w*viewW, oh = roi.h*viewH;
      const nx = Math.round((ox - offX)/scale);
      const ny = Math.round((oy - offY)/scale);
      const nw = Math.round(ow/scale);
      const nh = Math.round(oh/scale);
      const x = Math.max(0, Math.min(natW, nx));
      const y = Math.max(0, Math.min(natH, ny));
      const w = Math.max(1, Math.min(natW - x, nw));
      const h = Math.max(1, Math.min(natH - y, nh));
      return {x,y,w,h};
    }

    function roiToCanvas(roi){
      const {x,y,w,h} = mapRoiToNatural(roi);
      const off = new OffscreenCanvas(w,h);
      const g = off.getContext('2d');
      g.drawImage(state.activeBitmap, x,y,w,h, 0, 0, w, h);
      return off;
    }

    async function canvasToBlobUrl(cnv, type='image/png', quality=0.92){
      const blob = await cnv.convertToBlob({type, quality});
      return URL.createObjectURL(blob);
    }

    /* ===========================================================
       MRZ: Normalización & Parseo + enriquecimiento
    ============================================================ */
    function normalizeRawMRZ(t){
      return t
        .replace(/[^\dA-Z<\n]/g,'')
        .replace(/[ \t]+/g,'')
        .toUpperCase()
        .trim();
    }
    function splitNames(s){
      const parts = s.split('<<');
      const surname = (parts[0]||'').replace(/</g,' ').trim();
      const given = (parts[1]||'').replace(/</g,' ').trim();
      return {surname, given};
    }
    function parseTD3(lines){
      const L1 = (lines[0]||'').padEnd(44,'<').slice(0,44);
      const L2 = (lines[1]||'').padEnd(44,'<').slice(0,44);
      const docType = L1.slice(0,2).replace(/</g,'');
      const issuer = L1.slice(2,5).replace(/</g,'');
      const namePart = L1.slice(5);
      const {surname, given} = splitNames(namePart);
      const passportNumber = L2.slice(0,9).replace(/</g,'');
      const nationality = L2.slice(10,13).replace(/</g,'');
      const birth = L2.slice(13,19);
      const sex = L2.slice(20,21).replace(/</g,'');
      const expiry = L2.slice(21,27);
      const personal = L2.slice(28,42).replace(/</g,'');
      return {
        Formato:'TD3 (Pasaporte)',
        'Tipo de documento':docType,
        'País emisor':issuer,
        'Apellidos':surname,
        'Nombres':given,
        'Número de documento':passportNumber,
        'Nacionalidad':nationality,
        'Fecha de nacimiento (YYMMDD)':birth,
        'Sexo':sex,
        'Fecha de expiración (YYMMDD)':expiry,
        'Número personal':personal
      };
    }
    function parseTD1(lines){
      const L1 = (lines[0]||'').padEnd(30,'<').slice(0,30);
      const L2 = (lines[1]||'').padEnd(30,'<').slice(0,30);
      const L3 = (lines[2]||'').padEnd(30,'<').slice(0,30);
      const docType = L1.slice(0,2).replace(/</g,'');
      const country = L1.slice(2,5).replace(/</g,'');
      const number = L1.slice(5,14).replace(/</g,'');
      const birth = L2.slice(0,6);
      const sex = L2.slice(7,8);
      const expiry = L2.slice(8,14);
      const nationality = L2.slice(15,18).replace(/</g,'');
      const optional = L3.slice(0,30).replace(/</g,' ').trim();
      const {surname, given} = splitNames(L3);
      return {
        Formato:'TD1 (ID 3 líneas)',
        'Tipo de documento':docType,
        'País emisor':country,
        'Número de documento':number,
        'Fecha de nacimiento (YYMMDD)':birth,
        'Sexo':sex,
        'Fecha de expiración (YYMMDD)':expiry,
        'Nacionalidad':nationality,
        'Apellidos':surname,
        'Nombres':given,
        'Dato opcional':optional
      };
    }
    function parseTD2(lines){
      const L1 = (lines[0]||'').padEnd(36,'<').slice(0,36);
      const L2 = (lines[1]||'').padEnd(36,'<').slice(0,36);
      const docType = L1.slice(0,2).replace(/</g,'');
      const country = L1.slice(2,5).replace(/</g,'');
      const namePart = L1.slice(5);
      const {surname, given} = splitNames(namePart);
      const number = L2.slice(0,9).replace(/</g,'');
      const nationality = L2.slice(10,13).replace(/</g,'');
      const birth = L2.slice(13,19);
      const sex = L2.slice(20,21);
      const expiry = L2.slice(21,27);
      const optional = L2.slice(28,35).replace(/</g,' ').trim();
      return {
        Formato:'TD2 (ID 2 líneas)',
        'Tipo de documento':docType,
        'País emisor':country,
        'Apellidos':surname,
        'Nombres':given,
        'Número de documento':number,
        'Nacionalidad':nationality,
        'Fecha de nacimiento (YYMMDD)':birth,
        'Sexo':sex,
        'Fecha de expiración (YYMMDD)':expiry,
        'Dato opcional':optional
      };
    }
    function guessAndParseMRZ(raw){
      const text = normalizeRawMRZ(raw);
      const lines = text.split(/\n+/).map(s=>s.trim()).filter(Boolean);
      if(lines.length>=2 && lines.every(l=>l.length>=36)){
        const L = lines.map(l=>l.replace(/\s+/g,''));
        if(L[0].length>=44 || L[1].length>=44) return parseTD3([L[0].slice(0,44), L[1].slice(0,44)]);
        return parseTD2([L[0].slice(0,36), L[1].slice(0,36)]);
      }else if(lines.length>=3){
        const L = lines.slice(0,3).map(l=>l.replace(/\s+/g,''));
        return parseTD1([L[0].slice(0,30), L[1].slice(0,30), L[2].slice(0,30)]);
      }else{
        throw new Error('No se reconoce el formato MRZ.');
      }
    }

    function yyMMddToISO(yyMMdd){
      if(!/^\d{6}$/.test(yyMMdd)) return null;
      const yy = parseInt(yyMMdd.slice(0,2),10);
      const mm = parseInt(yyMMdd.slice(2,4),10);
      const dd = parseInt(yyMMdd.slice(4,6),10);
      const year = (yy >= 50 ? 1900 : 2000) + yy;
      if(mm<1||mm>12||dd<1||dd>31) return null;
      const m = String(mm).padStart(2,'0');
      const d = String(dd).padStart(2,'0');
      return `${year}-${m}-${d}`;
    }
    function isoToDate(iso){ const d = new Date(iso+'T00:00:00'); return isNaN(d.getTime()) ? null : d; }
    function yearsBetween(birthISO){
      const d = isoToDate(birthISO); if(!d) return null;
      const now = new Date();
      let age = now.getFullYear() - d.getFullYear();
      const m = now.getMonth() - d.getMonth();
      if(m < 0 || (m === 0 && now.getDate() < d.getDate())) age--;
      return age;
    }
    function daysUntilISO(iso){
      const d = isoToDate(iso); if(!d) return null;
      const now = new Date();
      const msPerDay = 24*60*60*1000;
      return Math.ceil((d - new Date(now.getFullYear(), now.getMonth(), now.getDate())) / msPerDay);
    }
    function augmentMRZ(parsed){
      const out = {...parsed};
      const kBirth = 'Fecha de nacimiento (YYMMDD)';
      const kExp   = 'Fecha de expiración (YYMMDD)';
      if(parsed[kBirth]){
        const iso = yyMMddToISO(parsed[kBirth]); if(iso){
          out['Fecha de nacimiento'] = iso;
          const age = yearsBetween(iso); if(age!=null) out['Edad (años)'] = String(age);
        }
      }
      if(parsed[kExp]){
        const iso = yyMMddToISO(parsed[kExp]); if(iso){
          out['Fecha de expiración'] = iso;
          const left = daysUntilISO(iso);
          if(left!=null){ out['Días hasta expiración'] = String(left); out['¿Vencido?'] = left < 0 ? 'Sí' : 'No'; }
        }
      }
      return out;
    }

    // ====== Área "Texto crudo OCR"
    document.getElementById('btnParseRaw').addEventListener('click', ()=>{
      const txt = ($raw.value||'').trim();
      if(!txt){ setStatus('No hay texto para parsear.', true); return; }
      parseToTable(txt);
      setStatus('Texto crudo parseado.');
    });

    function renderPairsTo(tableEl, obj){
      let html = '<div class="scroll-wrap"><table class="result-table"><thead><tr><th>Campo</th><th>Valor</th></tr></thead><tbody>';
      for (const [k,v] of Object.entries(obj)){
        const vv = (v ?? '') === '' ? '<span class="muted">—</span>' : escapeHtml(String(v));
        html += `<tr><td><strong>${escapeHtml(k)}</strong></td><td>${vv}</td></tr>`;
      }
      html += '</tbody></table></div>';
      tableEl.innerHTML = html;
    }

    function parseToTable(raw){
      // Primero MRZ
      try{
        const parsed = guessAndParseMRZ(raw);
        const enriched = augmentMRZ(parsed);
        mrzSummary.classList.remove('hidden');
        mrzSummary.innerHTML = "<strong>Resultados</strong> — <span class='ok'>MRZ parseado.</span>";
        renderPairsTo(mrzTable, enriched);
        addRoiResult({name:'(Texto crudo)', type:'text'}, enriched);

        // *** MRZ OK → cargar PDF417 y descargar Documento ***
        loadPDF417AfterMRZ();
        return;
      }catch(_){}

      // Si no es MRZ, intentar key:value genérico
      const rows = {};
      const lines = raw.split(/\r?\n+/).map(s=>s.trim()).filter(Boolean);
      for(const ln of lines){
        const m = ln.match(/^([^:]{2,48})\s*:\s*(.+)$/);
        if(m) rows[m[1].trim()] = m[2].trim();
      }
      if(Object.keys(rows).length===0){
        lines.slice(0,50).forEach((v,i)=>rows[`Línea ${i+1}`]=v);
      }
      mrzSummary.classList.remove('hidden');
      mrzSummary.innerHTML = "<strong>Resultados</strong> — <span class='warn'>Texto genérico (no MRZ).</span>";
      renderPairsTo(mrzTable, rows);
      addRoiResult({name:'(Texto crudo)', type:'text'}, rows);
    }

    // ====== Extracción por ROI
    document.getElementById('btnExtractSelected').addEventListener('click', async ()=>{
      const a = state.rois.find(r=>r.id===state.selectedRoiId);
      if(!a) return alert('Selecciona un ROI');
      await extractAndReportROI(a);
    });
    document.getElementById('btnExtractAll').addEventListener('click', async ()=>{
      if(!state.rois.length) return alert('No hay ROIs');
      for(const r of state.rois){ await extractAndReportROI(r); }
      setStatus('Extracción de todos los ROIs finalizada.');
    });

    async function extractAndReportROI(roi, originLabel=''){
      if(!state.activeBitmap){ alert('No hay imagen activa'); return; }
      const cnv = roiToCanvas(roi);
      const dataUrl = await canvasToBlobUrl(cnv);
      try{
        switch((roi.type||'text').toLowerCase()){
          case 'image':{
            addRoiResult(roi, {'Imagen exportada': (roi.name||roi.id)+'.png'});
            const a = document.createElement('a'); a.href = dataUrl; a.download = `${(roi.name||roi.id)}.png`; a.click();
            setStatus(`Imagen ROI "${roi.name||roi.id}" exportada.`);
            break;
          }
          case 'text':{
            const text = await ocrCanvas(cnv, 'spa+eng');
            $raw.value = text || '';
            parseToTable($raw.value);
            addRoiResult(roi, {'Texto': text||''});
            setStatus(`Texto extraído de "${roi.name||roi.id}".`);
            break;
          }
          case 'mrz':{
            const text = await ocrCanvas(cnv, 'eng');
            $raw.value = text || '';
            try{
              const parsed = guessAndParseMRZ(text||'');
              const enriched = augmentMRZ(parsed);
              mrzSummary.classList.remove('hidden');
              mrzSummary.innerHTML = "<strong>Resultados</strong> — <span class='ok'>MRZ parseado.</span>";
              renderPairsTo(mrzTable, enriched);
              addRoiResult(roi, enriched);
              setStatus(`MRZ parseado en "${roi.name||roi.id}".`);

              // *** MRZ OK → cargar PDF417 y descargar Documento ***
              loadPDF417AfterMRZ();
            }catch(e){
              mrzSummary.classList.remove('hidden');
              mrzSummary.innerHTML = "<strong>Resultados</strong> — <span class='err'>MRZ no reconocido.</span>";
              renderPairsTo(mrzTable, {'raw': (text||'(vacío)')});
              addRoiResult(roi, {'raw': text||'(vacío)'});
              setStatus(`MRZ no reconocido en "${roi.name||roi.id}".`, true);
            }
            break;
          }
          case 'pdf417':{
            const res = await decodeBarcodeWithZXing(dataUrl, ['PDF_417']);
            if(res){
              tryAutoParseDUIFromPDF417(res);
              const rawPDF = (extractRawTextFromPdf417(res) || '').trim();
              const parsed = parseDUIFromRaw(rawPDF);
              if(parsed && parsed.fields){
                addRoiResult(roi, parsed.fields);
              }else{
                addRoiResult(roi, {'Texto PDF417': rawPDF||'(vacío)'});
              }
              $raw.value = rawPDF;
              setStatus(`PDF417 decodificado en "${roi.name||roi.id}".`);
            }else{
              pdf417Error.classList.remove('hidden');
              pdf417Error.textContent = 'PDF417 Error: No se pudo decodificar.';
              pdf417Table.innerHTML = '<p class="muted">No se pudo decodificar PDF417.</p>';
              addRoiResult(roi, {'Error': 'No se pudo decodificar PDF417'});
              setStatus(`PDF417 no encontrado en "${roi.name||roi.id}".`, true);
            }
            break;
          }
          case 'barcode':{
            const res = await decodeBarcodeWithZXing(dataUrl, 'ALL');
            if(res){
              const txt = (res.getText? res.getText(): (res.text||'')) || '';
              const fmt = (res.getBarcodeFormat? res.getBarcodeFormat(): (res.format||'—'));
              $raw.value = txt.trim();
              parseToTable($raw.value);
              addRoiResult(roi, {'Formato': fmt, 'Texto': txt});
              setStatus(`Código de barras leído (${fmt}) en "${roi.name||roi.id}".`);
            }
            else {
              addRoiResult(roi, {'Error': 'No se pudo leer código'});
              setStatus(`No se pudo leer código en "${roi.name||roi.id}".`, true);
            }
            break;
          }
          default:{
            addRoiResult(roi, {'Error': `Tipo no soportado: ${roi.type}`});
            setStatus(`Tipo no soportado: ${roi.type}`, true);
          }
        }
      }finally{
        URL.revokeObjectURL(dataUrl);
      }
    }

    // Tabla de Resultados (ROIs)
    function ensureRoiResultsTable(){
      if(document.getElementById('roiResultsTable')) return;
      roiResults.innerHTML = `
        <table id="roiResultsTable" class="result-table">
          <thead>
            <tr><th>ROI</th><th>Tipo</th><th>Campo</th><th>Valor</th></tr>
          </thead>
          <tbody id="roiResultsBody"></tbody>
        </table>`;
    }
    function addRoiResult(roi, data){
      ensureRoiResultsTable();
      const body = document.getElementById('roiResultsBody');
      const roiName = escapeHtml(roi?.name || roi?.id || '(ROI)');
      const roiType = escapeHtml((roi?.type || 'text').toLowerCase());

      if(data && typeof data === 'object' && !Array.isArray(data)){
        for(const [k,v] of Object.entries(data)){
          const tr = document.createElement('tr');
          tr.innerHTML = `<td>${roiName}</td><td>${roiType}</td><td><strong>${escapeHtml(k)}</strong></td><td>${escapeHtml(String(v))}</td>`;
          body.appendChild(tr);
        }
      }else{
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${roiName}</td><td>${roiType}</td><td><strong>Texto</strong></td><td>${escapeHtml(String(data||''))}</td>`;
        body.appendChild(tr);
      }
    }

    async function ocrCanvas(cnv, langs='spa+eng'){
      const url = await canvasToBlobUrl(cnv);
      try{
        const worker = await Tesseract.createWorker(langs);
        const { data:{ text } } = await worker.recognize(url);
        await worker.terminate();
        return (text||'').trim();
      }catch(e){ console.error(e); return ''; }
      finally{ URL.revokeObjectURL(url); }
    }

    async function decodeBarcodeWithZXing(dataUrl, formats='ALL'){
      const img = await dataUrlToImage(dataUrl);
      try{
        if(formats==='ALL'){
          const reader = new ZXing.BrowserMultiFormatReader();
          const res = await reader.decodeFromImage(img).catch(()=>null);
          return res ? {getText: ()=>res.getText(), getBarcodeFormat: ()=>String(res.getBarcodeFormat())} : null;
        }else if(Array.isArray(formats) && formats.includes('PDF_417')){
          const pdfReader = new ZXing.BrowserPDF417Reader();
          let res = null;
          try{ res = await pdfReader.decodeOnce(img); }
          catch{ res = await pdfReader.decodeFromImage(img); }
          return res ? {getText: ()=>res.getText(), getBarcodeFormat: ()=> 'PDF_417'} : null;
        }
        return null;
      }catch(e){
        console.warn('ZXing decode error', e);
        return null;
      }
    }

    function dataUrlToImage(url){
      return new Promise((resolve,reject)=>{
        const img = new Image();
        img.onload = ()=>resolve(img);
        img.onerror = reject;
        img.src = url;
      });
    }

    function escapeHtml(s){ return String(s).replace(/[&<>"']/g, m=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"})[m]); }

    /* ===========================================================
       Inicio: BLOQUEA UI → carga modelos → activa Auto-Doc/MRZ
    ============================================================ */
    (async function init(){
      // Desactivar todo mientras cargan modelos Doc + MRZ
      setUIEnabled(false);
      step('Preparando… UI desactivada durante la carga');

      await initEngine();

      // Activar Auto-Doc desde el inicio
      document.getElementById('chkAutoDoc').checked = true;

      // Auto-MRZ ya está activo (checkboxes por defecto)
      // Auto-PDF417 permanece desactivado hasta que cargue tras MRZ

      // Arrancar cámara y re-habilitar UI
      await startCamera();
      resizeOverlay();
      syncRoiPropsPanel();
      updateRoiCount();

      setUIEnabled(true);
      stepOk('Listo. Auto-Doc activo, puedes apuntar el documento.');
      
      // Listeners switches (sin cambios de lógica)
      $chkAutoMrzCam.addEventListener('change', ()=>{ state.autoMrzCam = $chkAutoMrzCam.checked; });
      $mrzInterval.addEventListener('input', ()=>{ /* throttling leído en loop */ });
    })();
  </script>

  <!-- =====================================================================================
       ===  NOTA: El bloque de helpers DUI/PDF417 (parseDUIFromRaw, tryAutoParseDUIFromPDF417,
       ===  extractRawTextFromPdf417, etc.) se mantiene igual al de tu implementación previa.
       ===  Si lo tenías en este archivo, déjalo debajo; si lo cargas externamente, no cambies.
       ===================================================================================== -->
</body>
</html>
